{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_model/src/../src/model/model.ts"],"names":[],"mappings":"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","file":"model.js","sourcesContent":["/**\r\n * Functionality managing the match models\r\n *\r\n * @file\r\n */\r\n\r\n//import * as intf from 'constants';\r\nimport * as debugf from 'debugf';\r\n\r\nvar debuglog = debugf('model');\r\n\r\n// the hardcoded domain metamodel!\r\nconst DOMAIN_METAMODEL = 'metamodel';\r\n\r\n\r\n//const loadlog = logger.logger('modelload', '');\r\n\r\nimport *  as IMatch from '../match/ifmatch';\r\nimport * as InputFilterRules from '../match/rule';\r\n//import * as Tools from '../match/tools';\r\nimport * as fs from 'fs';\r\nimport * as Meta from './meta';\r\nimport * as Utils from 'abot_utils';\r\nimport * as CircularSer from 'abot_utils';\r\nimport * as Distance from 'abot_stringdist';\r\nimport * as process from 'process';\r\nimport * as _ from 'lodash';\r\n\r\nimport * as MongoUtils from '../utils/mongo';\r\n\r\nimport * as mongoose from 'mongoose';\r\nimport * as ISchema from '../modelload/schemaload';\r\nimport * as Schemaload from '../modelload/schemaload';\r\nimport * as MongoMap from './mongomap';\r\n\r\n/**\r\n * the model path, may be controlled via environment variable\r\n */\r\nvar envModelPath = process.env[\"ABOT_MODELPATH\"] || \"node_modules/mgnlq_testmodel/testmodel\";\r\n\r\n\r\nexport function cmpTools(a: IMatch.ITool, b: IMatch.ITool) {\r\n    return a.name.localeCompare(b.name);\r\n}\r\n\r\ntype IModel = IMatch.IModel;\r\n\r\n/**\r\n * returns when all models are loaded and all modeldocs are made\r\n * @param mongoose\r\n */\r\nexport function getMongoHandle(mongoose: mongoose.Mongoose): Promise<IMatch.IModelHandleRaw> {\r\n    var res = {\r\n        mongoose: mongoose,\r\n        modelDocs: {},\r\n        modelESchemas: {},\r\n        mongoMaps: {}\r\n    } as IMatch.IModelHandleRaw;\r\n    var modelES = Schemaload.getExtendedSchemaModel(mongoose);\r\n    return modelES.distinct('modelname').then((modelnames) => {\r\n        debuglog(() => 'here distinct modelnames ' + JSON.stringify(modelnames));\r\n        return Promise.all(modelnames.map(function (modelname) {\r\n            debuglog(() => 'creating tripel for ' + modelname);\r\n            return Promise.all([Schemaload.getExtendSchemaDocFromDB(mongoose, modelname),\r\n            Schemaload.makeModelFromDB(mongoose, modelname),\r\n            Schemaload.getModelDocFromDB(mongoose, modelname)]).then(\r\n                (value) => {\r\n                    debuglog(() => 'attempting to load ' + modelname + ' to create mongomap');\r\n                    var [extendedSchema, model, modelDoc] = value;\r\n                    res.modelESchemas[modelname] = extendedSchema;\r\n                    res.modelDocs[modelname] = modelDoc;\r\n                    res.mongoMaps[modelname] = MongoMap.makeMongoMap(modelDoc, extendedSchema)\r\n                    debuglog(()=> 'created mongomap for ' + modelname);\r\n                }\r\n                )\r\n        }));\r\n    }).then(() => {\r\n        return res;\r\n    })\r\n    //var modelDoc = Schemaload.getExtendedDocModel(mongoose);\r\n    //res.modelDocs[ISchema.MongoNLQ.MODELNAME_METAMODELS] = modelDoc;\r\n    //return Promise.resolve(res);\r\n}\r\n\r\nexport function getFactSynonyms(mongoHandle: IMatch.IModelHandleRaw, modelname: string): Promise<ISynonym[]> {\r\n    var model = mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n    //     return model.find( { \"_synonyms.0\" : { $exists: false}}).lean().exec();\r\n/* mongoose prior\r\n    return model.aggregate({ $match: { \"_synonyms.0\": { $exists: true } } },\r\n        { $project: { _synonyms: 1 } },\r\n        { $unwind: \"$_synonyms\" },\r\n        { $project: { \"category\": \"$_synonyms.category\", \"fact\": \"$_synonyms.fact\", \"synonyms\": \"$_synonyms.synonyms\" } }).exec();\r\n*/\r\n    return model.aggregate([{ $match: { \"_synonyms.0\": { $exists: true } } },\r\n        { $project: { _synonyms: 1 } },\r\n        { $unwind: \"$_synonyms\" },\r\n        { $project: { \"category\": \"$_synonyms.category\", \"fact\": \"$_synonyms.fact\", \"synonyms\": \"$_synonyms.synonyms\" } }]).exec();\r\n\r\n\r\n}\r\n\r\nexport interface ISynonym {\r\n    category: string,\r\n    fact: string,\r\n    synonyms: string[]\r\n};\r\n\r\nexport interface ISynonymBearingDoc {\r\n    _synonyms: [{\r\n        category: string,\r\n        fact: string,\r\n        synonyms: string[]\r\n    }]\r\n}\r\n\r\nexport function getMongoCollectionNameForDomain(theModel: IMatch.IModels, domain : string) : string {\r\n    var r = getMongooseModelNameForDomain(theModel, domain);\r\n    return Schemaload.makeMongoCollectionName(r)\r\n}\r\n\r\n//Schemaload.makeMongooseModelName(modelname)\r\n\r\nexport function getMongooseModelNameForDomain(theModel : IMatch.IModels, domain : string) : string {\r\n    var r = getModelNameForDomain(theModel.mongoHandle, domain);\r\n    var r2 = Schemaload.makeMongooseModelName(r);\r\n    return r2;\r\n}\r\n\r\n\r\nexport function getModelForModelName(theModel : IMatch.IModels, modelname: string) : any {\r\n    return theModel.mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n}\r\n\r\nexport function getModelForDomain(theModel : IMatch.IModels, domain : string) : any {\r\n    var modelname = getModelNameForDomain(theModel.mongoHandle, domain);\r\n    return getModelForModelName(theModel, modelname);\r\n}\r\n\r\nexport function getModelNameForDomain(handle : IMatch.IModelHandleRaw, domain : string) : string {\r\n    var res = undefined;\r\n    Object.keys(handle.modelDocs).every( key => {\r\n        var doc = handle.modelDocs[key];\r\n        if(domain === doc.domain) {\r\n            res = doc.modelname;\r\n        }\r\n        return !res;\r\n    });\r\n    if(!res) {\r\n        throw Error('attempt to retrieve modelName for unknown domain ' + domain);\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nexport function filterRemapCategories( mongoMap : IMatch.CatMongoMap, categories : string[], records : any[] ) : any[] {\r\n    //\r\n    //console.log('here map' + JSON.stringify(mongoMap,undefined,2));\r\n    return records.map((rec,index) => {\r\n        var res = {};\r\n        categories.forEach(category => {\r\n            var categoryPath = mongoMap[category].paths;\r\n            if(!categoryPath) {\r\n                throw new Error(`unknown category ${category} not present in ${JSON.stringify(mongoMap,undefined,2)}`);\r\n            }\r\n            res[category] = MongoMap.getMemberByPath(rec, categoryPath);\r\n            debuglog( ()=>'got member for '  + category + ' from rec no ' + index + ' ' + JSON.stringify(rec,undefined,2) );\r\n            debuglog(()=> JSON.stringify(categoryPath));\r\n            debuglog(()=> 'res : ' + res[category] );\r\n        });\r\n        return res;\r\n    });\r\n}\r\n\r\nexport function checkModelMongoMap(model: mongoose.Model<any>, modelname : string, mongoMap: IMatch.CatMongoMap, category? : string) {\r\n    if (!model) {\r\n        debuglog(' no model for ' + modelname);\r\n //       return Promise.reject(`model ${modelname} not found in db`);\r\n        throw Error(`model ${modelname} not found in db`);\r\n    }\r\n    if (!mongoMap) {\r\n        debuglog(' no mongoMap for ' + modelname);\r\n        throw new Error(`model ${modelname} has no modelmap`);\r\n//        return Promise.reject(`model ${modelname} has no modelmap`);\r\n    }\r\n    if (category && !mongoMap[category]) {\r\n        debuglog(' no mongoMap category for ' + modelname);\r\n  //      return Promise.reject(`model ${modelname} has no category ${category}`);\r\n          throw new Error(`model ${modelname} has no category ${category}`);\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getExpandedRecordsFull(theModel : IMatch.IModels, domain : string) : Promise<{ [key : string] : any}> {\r\n    var mongoHandle = theModel.mongoHandle;\r\n    var modelname = getModelNameForDomain(theModel.mongoHandle, domain);\r\n    debuglog(()=>` modelname for ${domain} is ${modelname}`);\r\n    var model = mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n    var mongoMap = mongoHandle.mongoMaps[modelname];\r\n    debuglog(()=> 'here the mongomap' + JSON.stringify(mongoMap,undefined,2));\r\n    var p = checkModelMongoMap(model,modelname, mongoMap);\r\n    debuglog(()=>` here the modelmap for ${domain} is ${JSON.stringify(mongoMap,undefined,2)}`);\r\n    // 1) produce the flattened records\r\n    var res = MongoMap.unwindsForNonterminalArrays(mongoMap);\r\n    debuglog(()=>'here the unwind statement ' + JSON.stringify(res,undefined,2));\r\n    // we have to unwind all common non-terminal collections.\r\n    debuglog(()=>'here the model ' + model.modelName);\r\n    var categories = getCategoriesForDomain(theModel, domain);\r\n    debuglog(()=>`here categories for ${domain} ${categories.join(';')}`);\r\n    if(res.length === 0) {\r\n        return model.find({}).lean().exec().then(( unwound : any[]) => {\r\n            debuglog(()=>'here res' + JSON.stringify(unwound));\r\n            return filterRemapCategories(mongoMap, categories, unwound)\r\n        });\r\n    }\r\n    return model.aggregate(res).then( unwound => {\r\n        // filter for aggregate\r\n        debuglog(()=>'here res' + JSON.stringify(unwound));\r\n        return filterRemapCategories(mongoMap, categories, unwound)\r\n    });\r\n}\r\n\r\n\r\nexport function getExpandedRecordsForCategory(theModel : IMatch.IModels,domain : string,category : string) : Promise<{ [key : string] : any}> {\r\n    var mongoHandle = theModel.mongoHandle;\r\n    var modelname = getModelNameForDomain(theModel.mongoHandle, domain);\r\n    debuglog(()=>` modelname for ${domain} is ${modelname}`);\r\n    //debuglog(() => `here models ${modelname} ` + mongoHandle.mongoose.modelNames().join(';'));\r\n    var model = mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n    var mongoMap = mongoHandle.mongoMaps[modelname];\r\n    debuglog(()=> 'here the mongomap' + JSON.stringify(mongoMap,undefined,2));\r\n    checkModelMongoMap(model,modelname, mongoMap,category);\r\n    debuglog(()=>` here the modelmap for ${domain} is ${JSON.stringify(mongoMap,undefined,2)}`);\r\n    // 1) produce the flattened records\r\n    var res = MongoMap.unwindsForNonterminalArrays(mongoMap);\r\n    debuglog(()=>'here the unwind statement ' + JSON.stringify(res,undefined,2));\r\n    // we have to unwind all common non-terminal collections.\r\n    debuglog(()=>'here the model ' + model.modelName);\r\n    if(res.length === 0) {\r\n        return model.find({}).lean().exec().then(( unwound : any[]) => {\r\n            debuglog(()=>'here res' + JSON.stringify(unwound));\r\n            return filterRemapCategories(mongoMap, [category], unwound)\r\n        });\r\n    }\r\n    return model.aggregate(res).then( unwound => {\r\n        // filter for aggregate\r\n        debuglog(()=>'here res' + JSON.stringify(unwound));\r\n        return filterRemapCategories(mongoMap, [category], unwound)\r\n    });\r\n}\r\n// get synonyms\r\n// db.cosmos.find( { \"_synonyms.0\": { $exists: true }}).length()\r\n\r\nexport function getDistinctValues(mongoHandle: IMatch.IModelHandleRaw, modelname: string, category: string): Promise<string[]> {\r\n    debuglog(() => `here models ${modelname} ` + mongoHandle.mongoose.modelNames().join(';'));\r\n    var model = mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n    var mongoMap = mongoHandle.mongoMaps[modelname];\r\n    checkModelMongoMap(model,modelname, mongoMap,category);\r\n    debuglog(' here path for distinct value ' + mongoMap[category].fullpath );\r\n    return model.distinct(mongoMap[category].fullpath).then(res => {\r\n        debuglog(() => ` here res for ${modelname}  ${category} values ` + JSON.stringify(res, undefined, 2));\r\n        return res;\r\n    });\r\n}\r\n\r\nconst ARR_MODEL_PROPERTIES = [\"domain\", \"bitindex\", \"defaultkeycolumn\", \"defaulturi\", \"categoryDescribed\", \"columns\", \"description\", \"tool\", \"toolhidden\", \"synonyms\", \"category\", \"wordindex\", \"exactmatch\", \"hidden\"];\r\n\r\nfunction addSynonyms(synonyms: string[], category: string, synonymFor: string, bitindex: number, bitSentenceAnd,\r\n    wordType: string,\r\n    mRules: Array<IMatch.mRule>, seen: { [key: string]: IMatch.mRule[] }) {\r\n    synonyms.forEach(function (syn) {\r\n        var oRule = {\r\n            category: category,\r\n            matchedString: synonymFor,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: syn,\r\n            bitindex: bitindex,\r\n            bitSentenceAnd: bitSentenceAnd,\r\n            wordType: wordType,\r\n            _ranking: 0.95\r\n        };\r\n        debuglog(debuglog.enabled ? (\"inserting synonym\" + JSON.stringify(oRule)) : '-');\r\n        insertRuleIfNotPresent(mRules, oRule, seen);\r\n    });\r\n}\r\n\r\nfunction getRuleKey(rule) {\r\n    var r1 = rule.matchedString + \"-|-\" + rule.category + \" -|- \" + rule.type + \" -|- \" + rule.word + \" \" + rule.bitindex + \" \" + rule.wordType;\r\n    if (rule.range) {\r\n        var r2 = getRuleKey(rule.range.rule);\r\n        r1 += \" -|- \" + rule.range.low + \"/\" + rule.range.high + \" -|- \" + r2;\r\n    }\r\n    return r1;\r\n}\r\n\r\n\r\nimport * as Breakdown from '../match/breakdown';\r\n\r\n/* given a rule which represents a word sequence which is split during tokenization */\r\nexport function addBestSplit(mRules: Array<IMatch.mRule>, rule: IMatch.mRule, seenRules: { [key: string]: IMatch.mRule[] }) {\r\n    //if(!global_AddSplits) {\r\n    //    return;\r\n    //}\r\n\r\n    if (rule.type !== IMatch.EnumRuleType.WORD) {\r\n        return;\r\n    }\r\n    var best = Breakdown.makeMatchPattern(rule.lowercaseword);\r\n    if (!best) {\r\n        return;\r\n    }\r\n    var newRule = {\r\n        category: rule.category,\r\n        matchedString: rule.matchedString,\r\n        bitindex: rule.bitindex,\r\n        bitSentenceAnd: rule.bitindex,\r\n        wordType: rule.wordType,\r\n        word: best.longestToken,\r\n        type: 0,\r\n        lowercaseword: best.longestToken,\r\n        _ranking: 0.95,\r\n        //    exactOnly : rule.exactOnly,\r\n        range: best.span\r\n    } as IMatch.mRule;\r\n    if (rule.exactOnly) {\r\n        newRule.exactOnly = rule.exactOnly\r\n    };\r\n    newRule.range.rule = rule;\r\n    insertRuleIfNotPresent(mRules, newRule, seenRules);\r\n}\r\n\r\n\r\nfunction insertRuleIfNotPresent(mRules: Array<IMatch.mRule>, rule: IMatch.mRule,\r\n    seenRules: { [key: string]: IMatch.mRule[] }) {\r\n\r\n    if (rule.type !== IMatch.EnumRuleType.WORD) {\r\n        debuglog('not a  word return fast '+ rule.matchedString);\r\n        mRules.push(rule);\r\n        return;\r\n    }\r\n    if ((rule.word === undefined) || (rule.matchedString === undefined)) {\r\n        throw new Error('illegal rule' + JSON.stringify(rule, undefined, 2));\r\n    }\r\n    var r = getRuleKey(rule);\r\n    /* if( (rule.word === \"service\" || rule.word=== \"services\") && r.indexOf('OData') >= 0) {\r\n         console.log(\"rulekey is\" + r);\r\n         console.log(\"presence is \" + JSON.stringify(seenRules[r]));\r\n     }*/\r\n    rule.lowercaseword = rule.word.toLowerCase();\r\n    if (seenRules[r]) {\r\n        debuglog(() => (\"Attempting to insert duplicate\" + JSON.stringify(rule, undefined, 2) + \" : \" + r));\r\n        var duplicates = seenRules[r].filter(function (oEntry) {\r\n            return 0 === InputFilterRules.compareMRuleFull(oEntry, rule);\r\n        });\r\n        if (duplicates.length > 0) {\r\n            return;\r\n        }\r\n    }\r\n    seenRules[r] = (seenRules[r] || []);\r\n    seenRules[r].push(rule);\r\n    if (rule.word === \"\") {\r\n        debuglog(debuglog.enabled ? ('Skipping rule with emtpy word ' + JSON.stringify(rule, undefined, 2)) : '-');\r\n        //g('Skipping rule with emtpy word ' + JSON.stringify(rule, undefined, 2));\r\n        return;\r\n    }\r\n    mRules.push(rule);\r\n    addBestSplit(mRules, rule, seenRules);\r\n    return;\r\n}\r\n\r\nexport function readFileAsJSON(filename: string): any {\r\n    var data = fs.readFileSync(filename, 'utf-8');\r\n    try {\r\n        return JSON.parse(data);\r\n    } catch (e) {\r\n        console.log(\"Content of file \" + filename + \" is no json\" + e);\r\n        process.exit(-1);\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/*\r\nfunction loadModelData1(modelPath: string, oMdl: IModel, sModelName: string, oModel: IMatch.IModels) {\r\n    // read the data ->\r\n    // data is processed into mRules directly,\r\n\r\n    var bitindex = oMdl.bitindex;\r\n    const sFileName = ('./' + modelPath + '/' + sModelName + \".data.json\");\r\n    var oMdlData= readFileAsJSON(sFileName);\r\n    oMdlData.forEach(function (oEntry) {\r\n        if (!oEntry.domain) {\r\n            oEntry._domain = oMdl.domain;\r\n        }\r\n        if (!oEntry.tool && oMdl.tool.name) {\r\n            oEntry.tool = oMdl.tool.name;\r\n        }\r\n        oModel.records.push(oEntry);\r\n        oMdl.category.forEach(function (cat) {\r\n            if (oEntry[cat] === 'undefined') {\r\n                oEntry[cat] = \"n/a\";\r\n                var bug =\r\n                    \"INCONSISTENT*> ModelData \" + sFileName + \" does not contain category \" + cat + \" with value 'undefined', undefined is illegal value, use n/a \" + JSON.stringify(oEntry) + \"\";\r\n                debuglog(bug);\r\n                //console.log(bug);\r\n                //process.exit(-1);\r\n            }\r\n        })\r\n\r\n        oMdl.wordindex.forEach(function (category) {\r\n            if (oEntry[category] === undefined) {\r\n                debuglog(\"INCONSISTENT*> ModelData \" + sFileName + \" does not contain category \" + category + \" of wordindex\" + JSON.stringify(oEntry) + \"\")\r\n                return;\r\n            }\r\n            if (oEntry[category] !== \"*\") {\r\n                var sString = oEntry[category];\r\n                debuglog(\"pushing rule with \" + category + \" -> \" + sString);\r\n                var oRule = {\r\n                    category: category,\r\n                    matchedString: sString,\r\n                    type: IMatch.EnumRuleType.WORD,\r\n                    word: sString,\r\n                    bitindex: bitindex,\r\n                    bitSentenceAnd : bitindex,\r\n                    wordType : IMatch.WORDTYPE.FACT,\r\n                    _ranking: 0.95\r\n                } as IMatch.mRule;\r\n                if (oMdl.exactmatch && oMdl.exactmatch.indexOf(category) >= 0) {\r\n                    oRule.exactOnly = true;\r\n                }\r\n                insertRuleIfNotPresent(oModel.mRules, oRule, oModel.seenRules);\r\n                if (oMdlData.synonyms && oMdlData.synonyms[category]) {\r\n                    throw new Error(\"how can this happen?\");\r\n                    //addSynonyms(oMdlData.synonyms[category], category, sString, bitindex, bitindex, \"X\", oModel.mRules, oModel.seenRules);\r\n                }\r\n                // a synonym for a FACT\r\n                if (oEntry.synonyms && oEntry.synonyms[category]) {\r\n                    addSynonyms(oEntry.synonyms[category], category, sString, bitindex, bitindex, IMatch.WORDTYPE.FACT, oModel.mRules, oModel.seenRules);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n*/\r\n\r\n\r\nexport function hasRuleWithFact(mRules : IMatch.mRule[], fact: string, category: string, bitindex: number) {\r\n    // TODO BAD QUADRATIC\r\n    return mRules.find( rule => {\r\n        return rule.word === fact && rule.category === category && rule.bitindex === bitindex\r\n    }) !== undefined;\r\n}\r\n\r\nfunction loadModelDataMongo(modelHandle: IMatch.IModelHandleRaw, oMdl: IModel, sModelName: string, oModel: IMatch.IModels): Promise<any> {\r\n    // read the data ->\r\n    // data is processed into mRules directly\r\n\r\n    var bitindex = oMdl.bitindex;\r\n    //const sFileName = ('./' + modelPath + '/' + sModelName + \".data.json\");\r\n    return Promise.all(modelHandle.modelDocs[sModelName]._categories.map(\r\n        categoryRec => {\r\n            var category = categoryRec.category;\r\n            var wordindex = categoryRec.wordindex;\r\n            if (!wordindex) {\r\n                return Promise.resolve(true);\r\n            }\r\n            else {\r\n                debuglog(() => 'adding values for ' + sModelName + ' ' +  category);\r\n                return getDistinctValues(modelHandle, sModelName, category).then(\r\n                    (values) => {\r\n                        debuglog(`found ${values.length} values for ${sModelName} ${category} `);\r\n                        values.map(value => {\r\n                            var sString = \"\" + value;\r\n                            debuglog(() => \"pushing rule with \" + category + \" -> \" + sString + ' ');\r\n                            var oRule = {\r\n                                category: category,\r\n                                matchedString: sString,\r\n                                type: IMatch.EnumRuleType.WORD,\r\n                                word: sString,\r\n                                bitindex: bitindex,\r\n                                bitSentenceAnd: bitindex,\r\n                                exactOnly: categoryRec.exactmatch || false,\r\n                                wordType: IMatch.WORDTYPE.FACT,\r\n                                _ranking: 0.95\r\n                            } as IMatch.mRule;\r\n                            insertRuleIfNotPresent(oModel.mRules, oRule, oModel.seenRules);\r\n                            //    if (oMdlData.synonyms && oMdlData.synonyms[category]) {\r\n                            //        throw new Error(\"how can this happen?\");\r\n                            //addSynonyms(oMdlData.synonyms[category], category, sString, bitindex, bitindex, \"X\", oModel.mRules, oModel.seenRules);\r\n                            //    }\r\n                            // a synonym for a FACT\r\n                            //    if (oEntry.synonyms && oEntry.synonyms[category]) {\r\n                            //         addSynonyms(oEntry.synonyms[category], category, sString, bitindex, bitindex, IMatch.WORDTYPE.FACT, oModel.mRules, oModel.seenRules);\r\n                            //     }\r\n                        });\r\n                        return true;\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    )\r\n    ).then(\r\n        () =>  getFactSynonyms(modelHandle, sModelName)\r\n    ).then((synonymValues : any) => {\r\n        synonymValues.forEach((synonymRec) => {\r\n        if (!hasRuleWithFact(oModel.mRules, synonymRec.fact, synonymRec.category, bitindex)) {\r\n            debuglog(() =>JSON.stringify(oModel.mRules,undefined,2));\r\n            throw Error(`Orphaned synonym without base in data?\\n`\r\n                                +\r\n                                `(check typos and that category is wordindexed!) fact: '${synonymRec.fact}';  category: \"${synonymRec.category}\"   `  + JSON.stringify(synonymRec))\r\n        }\r\n        addSynonyms(synonymRec.synonyms, synonymRec.category, synonymRec.fact, bitindex, bitindex, IMatch.WORDTYPE.FACT,\r\n                                oModel.mRules, oModel.seenRules);\r\n                            return true;\r\n                        });\r\n        return true;\r\n    });\r\n};\r\n\r\n/*\r\nfunction loadModelP(mongooseHndl : mongoose.Mongoose, modelPath: string, connectionString : string) : Promise<IMatch.IModels> {\r\n    var mongooseX = mongooseHndl || mongoose;\r\n    var connStr = connectionString || 'mongodb://localhost/testdb';\r\n    return MongoUtils.openMongoose(mongooseX, connStr).then(\r\n        () => getMongoHandle(mongooseX)\r\n    ).then( (modelHandle : IMatch.IModelHandleRaw) => _loadModelsFull(modelHandle, modelPath)\r\n    );\r\n};\r\n*/\r\n\r\n\r\n\r\n\r\nexport function loadModel(modelHandle: IMatch.IModelHandleRaw, sModelName: string, oModel: IMatch.IModels): Promise<any> {\r\n    debuglog(\" loading \" + sModelName + \" ....\");\r\n    //var oMdl = readFileAsJSON('./' + modelPath + '/' + sModelName + \".model.json\") as IModel;\r\n    var oMdl = makeMdlMongo(modelHandle, sModelName, oModel);\r\n    return loadModelDataMongo(modelHandle, oMdl, sModelName, oModel);\r\n}\r\n\r\n\r\nexport function getAllDomainsBitIndex(oModel: IMatch.IModels): number {\r\n    var len = oModel.domains.length;\r\n    var res = 0;\r\n    for (var i = 0; i < len; ++i) {\r\n        res = res << 1;\r\n        res = res | 0x0001;\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function getDomainBitIndex(domain: string, oModel: IMatch.IModels): number {\r\n    var index = oModel.domains.indexOf(domain);\r\n    if (index < 0) {\r\n        index = oModel.domains.length;\r\n    }\r\n    if (index >= 32) {\r\n        throw new Error(\"too many domain for single 32 bit index\");\r\n    }\r\n    return 0x0001 << index;\r\n}\r\n\r\nexport function getDomainBitIndexSafe(domain: string, oModel: IMatch.IModels): number {\r\n    var index = oModel.domains.indexOf(domain);\r\n    if (index < 0) {\r\n        throw Error('expected domain to be registered??? ');\r\n    }\r\n    if (index >= 32) {\r\n        throw new Error(\"too many domain for single 32 bit index\");\r\n    }\r\n    return 0x0001 << index;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Given a bitfield, return an unsorted set of domains matching present bits\r\n * @param oModel\r\n * @param bitfield\r\n */\r\nexport function getDomainsForBitField(oModel: IMatch.IModels, bitfield: number): string[] {\r\n    return oModel.domains.filter(domain =>\r\n        (getDomainBitIndex(domain, oModel) & bitfield)\r\n    );\r\n}\r\n\r\n/*\r\nfunction mergeModelJson(sModelName: string, oMdl: IModel, oModel: IMatch.IModels) {\r\n    var categoryDescribedMap = {} as { [key: string]: IMatch.ICategoryDesc };\r\n    oMdl.bitindex = getDomainBitIndex(oMdl.domain, oModel);\r\n    oMdl.categoryDescribed = [];\r\n    // rectify category\r\n    oMdl.category = oMdl.category.map(function (cat: any) {\r\n        if (typeof cat === \"string\") {\r\n            return cat;\r\n        }\r\n        if (typeof cat.name !== \"string\") {\r\n            console.log(\"Missing name in object typed category in \" + JSON.stringify(cat) + \" in model \" + sModelName);\r\n            process.exit(-1);\r\n            //throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n        }\r\n        categoryDescribedMap[cat.name] = cat;\r\n        oMdl.categoryDescribed.push(cat);\r\n        return cat.name;\r\n    });\r\n\r\n    // add the categories to the model:\r\n    oMdl.category.forEach(function (category) {\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"category\",\r\n            matchedString: category,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: category,\r\n            lowercaseword: category.toLowerCase(),\r\n            bitindex: oMdl.bitindex,\r\n            wordType : IMatch.WORDTYPE.CATEGORY,\r\n            bitSentenceAnd : oMdl.bitindex,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n    });\r\n\r\n    if (oModel.domains.indexOf(oMdl.domain) >= 0) {\r\n        debuglog(\"***********here mdl\" + JSON.stringify(oMdl, undefined, 2));\r\n        throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n    }\r\n    // check properties of model\r\n    Object.keys(oMdl).sort().forEach(function (sProperty) {\r\n        if (ARR_MODEL_PROPERTIES.indexOf(sProperty) < 0) {\r\n            throw new Error('Model property \"' + sProperty + '\" not a known model property in model of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    // consider streamlining the categories\r\n    oModel.rawModels[oMdl.domain] = oMdl;\r\n\r\n    oModel.full.domain[oMdl.domain] = {\r\n        description: oMdl.description,\r\n        categories: categoryDescribedMap,\r\n        bitindex: oMdl.bitindex\r\n    };\r\n\r\n    // check that\r\n\r\n\r\n    // check that members of wordindex are in categories,\r\n    oMdl.wordindex = oMdl.wordindex || [];\r\n    oMdl.wordindex.forEach(function (sWordIndex) {\r\n        if (oMdl.category.indexOf(sWordIndex) < 0) {\r\n            throw new Error('Model wordindex \"' + sWordIndex + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    oMdl.exactmatch = oMdl.exactmatch || [];\r\n    oMdl.exactmatch.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model exactmatch \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    oMdl.columns = oMdl.columns || [];\r\n    oMdl.columns.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model column \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n\r\n\r\n    // add relation domain -> category\r\n    var domainStr = MetaF.Domain(oMdl.domain).toFullString();\r\n    var relationStr = MetaF.Relation(Meta.RELATION_hasCategory).toFullString();\r\n    var reverseRelationStr = MetaF.Relation(Meta.RELATION_isCategoryOf).toFullString();\r\n    oMdl.category.forEach(function (sCategory) {\r\n\r\n        var CategoryString = MetaF.Category(sCategory).toFullString();\r\n        oModel.meta.t3[domainStr] = oModel.meta.t3[domainStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr] = oModel.meta.t3[domainStr][relationStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr][CategoryString] = {};\r\n\r\n        oModel.meta.t3[CategoryString] = oModel.meta.t3[CategoryString] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr] = oModel.meta.t3[CategoryString][reverseRelationStr] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr][domainStr] = {};\r\n\r\n    });\r\n\r\n    // add a precice domain matchrule\r\n    insertRuleIfNotPresent(oModel.mRules, {\r\n        category: \"domain\",\r\n        matchedString: oMdl.domain,\r\n        type: IMatch.EnumRuleType.WORD,\r\n        word: oMdl.domain,\r\n        bitindex: oMdl.bitindex,\r\n        bitSentenceAnd : oMdl.bitindex,\r\n        wordType : \"D\",\r\n        _ranking: 0.95\r\n    }, oModel.seenRules);\r\n\r\n    // check the tool\r\n    if (oMdl.tool && oMdl.tool.requires) {\r\n        var requires = Object.keys(oMdl.tool.requires || {});\r\n        var diff = _.difference(requires, oMdl.category);\r\n        if (diff.length > 0) {\r\n            console.log(` ${oMdl.domain} : Unkown category in requires of tool: \"` + diff.join('\"') + '\"');\r\n            process.exit(-1);\r\n        }\r\n        var optional = Object.keys(oMdl.tool.optional);\r\n        diff = _.difference(optional, oMdl.category);\r\n        if (diff.length > 0) {\r\n            console.log(` ${oMdl.domain} : Unkown category optional of tool: \"` + diff.join('\"') + '\"');\r\n            process.exit(-1);\r\n        }\r\n        Object.keys(oMdl.tool.sets || {}).forEach(function (setID) {\r\n            var diff = _.difference(oMdl.tool.sets[setID].set, oMdl.category);\r\n            if (diff.length > 0) {\r\n                console.log(` ${oMdl.domain} : Unkown category in setId ${setID} of tool: \"` + diff.join('\"') + '\"');\r\n                process.exit(-1);\r\n            }\r\n        });\r\n\r\n        // extract tools an add to tools:\r\n        oModel.tools.filter(function (oEntry) {\r\n            if (oEntry.name === (oMdl.tool && oMdl.tool.name)) {\r\n                console.log(\"Tool \" + oMdl.tool.name + \" already present when loading \" + sModelName);\r\n                //throw new Error('Domain already loaded?');\r\n                process.exit(-1);\r\n            }\r\n        });\r\n    } else {\r\n        oMdl.toolhidden = true;\r\n        oMdl.tool.requires = { \"impossible\": {} };\r\n    }\r\n    // add the tool name as rule unless hidden\r\n    if (!oMdl.toolhidden && oMdl.tool && oMdl.tool.name) {\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"tool\",\r\n            matchedString: oMdl.tool.name,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: oMdl.tool.name,\r\n            bitindex: oMdl.bitindex,\r\n            bitSentenceAnd : oMdl.bitindex,\r\n            wordType : IMatch.WORDTYPE.TOOL,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n    };\r\n    if (oMdl.synonyms && oMdl.synonyms[\"tool\"]) {\r\n        addSynonyms(oMdl.synonyms[\"tool\"], \"tool\", oMdl.tool.name, oMdl.bitindex,\r\n        oMdl.bitindex, IMatch.WORDTYPE.TOOL, oModel.mRules, oModel.seenRules);\r\n    };\r\n    if (oMdl.synonyms) {\r\n        Object.keys(oMdl.synonyms).forEach(function (ssynkey) {\r\n            if (oMdl.category.indexOf(ssynkey) >= 0 && ssynkey !== \"tool\") {\r\n                if (oModel.full.domain[oMdl.domain].categories[ssynkey]) {\r\n                    oModel.full.domain[oMdl.domain].categories[ssynkey].category_synonyms = oMdl.synonyms[ssynkey];\r\n                }\r\n                addSynonyms(oMdl.synonyms[ssynkey], \"category\", ssynkey, oMdl.bitindex, oMdl.bitindex,\r\n                IMatch.WORDTYPE.CATEGORY, oModel.mRules, oModel.seenRules);\r\n            }\r\n        });\r\n    }\r\n    oModel.domains.push(oMdl.domain);\r\n    if (oMdl.tool.name) {\r\n        oModel.tools.push(oMdl.tool);\r\n    }\r\n    oModel.category = oModel.category.concat(oMdl.category);\r\n    oModel.category.sort();\r\n    oModel.category = oModel.category.filter(function (string, index) {\r\n        return oModel.category[index] !== oModel.category[index + 1];\r\n    });\r\n\r\n} // loadmodel\r\n*/\r\n\r\nfunction makeMdlMongo(modelHandle: IMatch.IModelHandleRaw, sModelName: string, oModel: IMatch.IModels): IModel {\r\n    var modelDoc = modelHandle.modelDocs[sModelName];\r\n    var oMdl = {\r\n        bitindex: getDomainBitIndexSafe(modelDoc.domain, oModel),\r\n        domain: modelDoc.domain,\r\n        modelname: sModelName,\r\n        description: modelDoc.domain_description\r\n    } as IModel;\r\n    var categoryDescribedMap = {} as { [key: string]: IMatch.ICategoryDesc };\r\n\r\n    oMdl.bitindex = getDomainBitIndexSafe(modelDoc.domain, oModel);\r\n    oMdl.category = modelDoc._categories.map(cat => cat.category);\r\n    oMdl.categoryDescribed = [];\r\n    modelDoc._categories.forEach(cat => {\r\n        oMdl.categoryDescribed.push({\r\n            name: cat.category,\r\n            description: cat.category_description\r\n        })\r\n        categoryDescribedMap[cat.category] = cat;\r\n    });\r\n\r\n    oMdl.category = modelDoc._categories.map(cat => cat.category);\r\n\r\n    /* // rectify category\r\n     oMdl.category = oMdl.category.map(function (cat: any) {\r\n         if (typeof cat === \"string\") {\r\n             return cat;\r\n         }\r\n         if (typeof cat.name !== \"string\") {\r\n             console.log(\"Missing name in object typed category in \" + JSON.stringify(cat) + \" in model \" + sModelName);\r\n             process.exit(-1);\r\n             //throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n         }\r\n         categoryDescribedMap[cat.name] = cat;\r\n         oMdl.categoryDescribed.push(cat);\r\n         return cat.name;\r\n     });\r\n     */\r\n\r\n    // add the categories to the rules\r\n    oMdl.category.forEach(function (category) {\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"category\",\r\n            matchedString: category,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: category,\r\n            lowercaseword: category.toLowerCase(),\r\n            bitindex: oMdl.bitindex,\r\n            wordType: IMatch.WORDTYPE.CATEGORY,\r\n            bitSentenceAnd: oMdl.bitindex,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n    });\r\n\r\n    // add synonanym for the categories to the\r\n\r\n    modelDoc._categories.forEach(cat => {\r\n        addSynonyms\r\n\r\n    });\r\n\r\n    if (oModel.domains.indexOf(oMdl.domain) < 0) {\r\n        debuglog(\"***********here mdl\" + JSON.stringify(oMdl, undefined, 2));\r\n        throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n    }\r\n    /*\r\n    // check properties of model\r\n    Object.keys(oMdl).sort().forEach(function (sProperty) {\r\n        if (ARR_MODEL_PROPERTIES.indexOf(sProperty) < 0) {\r\n            throw new Error('Model property \"' + sProperty + '\" not a known model property in model of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    */\r\n\r\n    // consider streamlining the categories\r\n    oModel.rawModels[oMdl.domain] = oMdl;\r\n\r\n    oModel.full.domain[oMdl.domain] = {\r\n        description: oMdl.description,\r\n        categories: categoryDescribedMap,\r\n        bitindex: oMdl.bitindex\r\n    };\r\n\r\n    // check that\r\n\r\n\r\n    // check that members of wordindex are in categories,\r\n    /* oMdl.wordindex = oModelDoc.oMdl.wordindex || [];\r\n     oMdl.wordindex.forEach(function (sWordIndex) {\r\n         if (oMdl.category.indexOf(sWordIndex) < 0) {\r\n             throw new Error('Model wordindex \"' + sWordIndex + '\" not a category of domain ' + oMdl.domain + ' ');\r\n         }\r\n     });\r\n     */\r\n    /*\r\n    oMdl.exactmatch = oMdl.exactmatch || [];\r\n    oMdl.exactmatch.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model exactmatch \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    */\r\n    oMdl.columns = modelDoc.columns; // oMdl.columns || [];\r\n    oMdl.columns.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model column \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n\r\n\r\n    // add relation domain -> category\r\n    var domainStr = MetaF.Domain(oMdl.domain).toFullString();\r\n    var relationStr = MetaF.Relation(Meta.RELATION_hasCategory).toFullString();\r\n    var reverseRelationStr = MetaF.Relation(Meta.RELATION_isCategoryOf).toFullString();\r\n    oMdl.category.forEach(function (sCategory) {\r\n\r\n        var CategoryString = MetaF.Category(sCategory).toFullString();\r\n        oModel.meta.t3[domainStr] = oModel.meta.t3[domainStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr] = oModel.meta.t3[domainStr][relationStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr][CategoryString] = {};\r\n\r\n        oModel.meta.t3[CategoryString] = oModel.meta.t3[CategoryString] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr] = oModel.meta.t3[CategoryString][reverseRelationStr] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr][domainStr] = {};\r\n\r\n    });\r\n\r\n    // add a precice domain matchrule\r\n    insertRuleIfNotPresent(oModel.mRules, {\r\n        category: \"domain\",\r\n        matchedString: oMdl.domain,\r\n        type: IMatch.EnumRuleType.WORD,\r\n        word: oMdl.domain,\r\n        bitindex: oMdl.bitindex,\r\n        bitSentenceAnd: oMdl.bitindex,\r\n        wordType: IMatch.WORDTYPE.DOMAIN,\r\n        _ranking: 0.95\r\n    }, oModel.seenRules);\r\n\r\n    // add domain synonyms\r\n    if (modelDoc.domain_synonyms && modelDoc.domain_synonyms.length > 0) {\r\n        addSynonyms(modelDoc.domain_synonyms, \"domain\", modelDoc.domain, oMdl.bitindex,\r\n            oMdl.bitindex, IMatch.WORDTYPE.DOMAIN, oModel.mRules, oModel.seenRules);\r\n        addSynonyms(modelDoc.domain_synonyms, \"domain\", modelDoc.domain, getDomainBitIndexSafe(DOMAIN_METAMODEL, oModel),\r\n                  getDomainBitIndexSafe(DOMAIN_METAMODEL, oModel),\r\n                IMatch.WORDTYPE.FACT, oModel.mRules, oModel.seenRules);\r\n        // TODO: synonym have to be added as *FACT* for the metamodel!\r\n\r\n    };\r\n\r\n\r\n    /*\r\n        // check the tool\r\n        if (oMdl.tool && oMdl.tool.requires) {\r\n            var requires = Object.keys(oMdl.tool.requires || {});\r\n            var diff = _.difference(requires, oMdl.category);\r\n            if (diff.length > 0) {\r\n                console.log(` ${oMdl.domain} : Unkown category in requires of tool: \"` + diff.join('\"') + '\"');\r\n                process.exit(-1);\r\n            }\r\n            var optional = Object.keys(oMdl.tool.optional);\r\n            diff = _.difference(optional, oMdl.category);\r\n            if (diff.length > 0) {\r\n                console.log(` ${oMdl.domain} : Unkown category optional of tool: \"` + diff.join('\"') + '\"');\r\n                process.exit(-1);\r\n            }\r\n            Object.keys(oMdl.tool.sets || {}).forEach(function (setID) {\r\n                var diff = _.difference(oMdl.tool.sets[setID].set, oMdl.category);\r\n                if (diff.length > 0) {\r\n                    console.log(` ${oMdl.domain} : Unkown category in setId ${setID} of tool: \"` + diff.join('\"') + '\"');\r\n                    process.exit(-1);\r\n                }\r\n            });\r\n\r\n            // extract tools an add to tools:\r\n            oModel.tools.filter(function (oEntry) {\r\n                if (oEntry.name === (oMdl.tool && oMdl.tool.name)) {\r\n                    console.log(\"Tool \" + oMdl.tool.name + \" already present when loading \" + sModelName);\r\n                    //throw new Error('Domain already loaded?');\r\n                    process.exit(-1);\r\n                }\r\n            });\r\n        } else {\r\n            oMdl.toolhidden = true;\r\n            oMdl.tool.requires = { \"impossible\": {} };\r\n        }\r\n        // add the tool name as rule unless hidden\r\n        if (!oMdl.toolhidden && oMdl.tool && oMdl.tool.name) {\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"tool\",\r\n                matchedString: oMdl.tool.name,\r\n                type: IMatch.EnumRuleType.WORD,\r\n                word: oMdl.tool.name,\r\n                bitindex: oMdl.bitindex,\r\n                bitSentenceAnd : oMdl.bitindex,\r\n                wordType : IMatch.WORDTYPE.TOOL,\r\n                _ranking: 0.95\r\n            }, oModel.seenRules);\r\n        };\r\n        if (oMdl.synonyms && oMdl.synonyms[\"tool\"]) {\r\n            addSynonyms(oMdl.synonyms[\"tool\"], \"tool\", oMdl.tool.name, oMdl.bitindex,\r\n            oMdl.bitindex, IMatch.WORDTYPE.TOOL, oModel.mRules, oModel.seenRules);\r\n        };\r\n        */\r\n\r\n    // add synsonym for the domains\r\n\r\n\r\n    // add synonyms for the categories\r\n\r\n    modelDoc._categories.forEach(cat => {\r\n        if (cat.category_synonyms && cat.category_synonyms.length > 0) {\r\n            if (oModel.full.domain[oMdl.domain].categories[cat.category]) {\r\n                oModel.full.domain[oMdl.domain].categories[cat.category].category_synonyms = cat.category_synonyms;\r\n            }\r\n            addSynonyms(cat.category_synonyms, \"category\", cat.category, oMdl.bitindex, oMdl.bitindex,\r\n                IMatch.WORDTYPE.CATEGORY, oModel.mRules, oModel.seenRules);\r\n            // add synonyms into the metamodel domain\r\n            addSynonyms(cat.category_synonyms, \"category\", cat.category, getDomainBitIndexSafe(DOMAIN_METAMODEL, oModel),\r\n                  getDomainBitIndexSafe(DOMAIN_METAMODEL, oModel),\r\n                IMatch.WORDTYPE.FACT, oModel.mRules, oModel.seenRules);\r\n        }\r\n    }\r\n    );\r\n\r\n    // add operators\r\n\r\n    // add fillers\r\n    if(oModel.domains.indexOf(oMdl.domain) < 0) {\r\n        throw Error('missing domain registration for ' + oMdl.domain);\r\n    }\r\n    //oModel.domains.push(oMdl.domain);\r\n    oModel.category = oModel.category.concat(oMdl.category);\r\n    oModel.category.sort();\r\n    oModel.category = oModel.category.filter(function (string, index) {\r\n        return oModel.category[index] !== oModel.category[index + 1];\r\n    });\r\n    return oMdl;\r\n} // loadmodel\r\n\r\n\r\n\r\nexport function splitRules(rules: IMatch.mRule[]): IMatch.SplitRules {\r\n    var res = {};\r\n    var nonWordRules = [];\r\n    rules.forEach(function (rule) {\r\n        if (rule.type === IMatch.EnumRuleType.WORD) {\r\n            if (!rule.lowercaseword) {\r\n                throw new Error(\"Rule has no member lowercaseword\" + JSON.stringify(rule));\r\n            }\r\n            res[rule.lowercaseword] = res[rule.lowercaseword] || { bitindex: 0, rules: [] };\r\n            res[rule.lowercaseword].bitindex = res[rule.lowercaseword].bitindex | rule.bitindex;\r\n            res[rule.lowercaseword].rules.push(rule);\r\n        } else {\r\n            nonWordRules.push(rule);\r\n        }\r\n    });\r\n    return {\r\n        wordMap: res,\r\n        nonWordRules: nonWordRules,\r\n        allRules: rules,\r\n        wordCache: {}\r\n    };\r\n}\r\n\r\n\r\nexport function sortFlatRecords(a,b) {\r\n    var keys = _.union(Object.keys(a),Object.keys(b)).sort();\r\n    var r = 0;\r\n    keys.every( (key) => {\r\n        if(typeof a[key] === \"string\" && typeof b[key] !== \"string\") {\r\n            r = -1;\r\n            return false;\r\n        }\r\n        if(typeof a[key] !== \"string\" && typeof b[key] === \"string\") {\r\n            r = +1;\r\n            return false;\r\n        }\r\n        if(typeof a[key] !== \"string\" && typeof b[key] !== \"string\") {\r\n            r = 0;\r\n            return true;\r\n        }\r\n        r = a[key].localeCompare(b[key]);\r\n        return r === 0;\r\n    });\r\n    return r;\r\n};\r\n\r\n\r\nfunction cmpLengthSort(a: string, b: string) {\r\n    var d = a.length - b.length;\r\n    if (d) {\r\n        return d;\r\n    }\r\n    return a.localeCompare(b);\r\n}\r\n\r\n\r\nimport * as Algol from '../match/algol';\r\n// offset[0] : len-2\r\n//             len -1\r\n//             len\r\n//             len +1\r\n//             len +2\r\n//             len +3\r\n\r\nexport function findNextLen(targetLen: number, arr: string[], offsets: number[]) {\r\n    offsets.shift();\r\n    for (var i = offsets[4]; (i < arr.length) && (arr[i].length <= targetLen); ++i) {\r\n        /* empty*/\r\n    }\r\n    //console.log(\"pushing \" + i);\r\n    offsets.push(i);\r\n}\r\n\r\nexport function addRangeRulesUnlessPresent(rules: IMatch.mRule[], lcword: string, rangeRules: IMatch.mRule[], presentRulesForKey: IMatch.mRule[], seenRules) {\r\n    rangeRules.forEach(rangeRule => {\r\n        var newRule = (Object as any).assign({}, rangeRule);\r\n        newRule.lowercaseword = lcword;\r\n        newRule.word = lcword;\r\n        //if((lcword === 'services' || lcword === 'service') && newRule.range.rule.lowercaseword.indexOf('odata')>=0) {\r\n        //    console.log(\"adding \"+ JSON.stringify(newRule) + \"\\n\");\r\n        //}\r\n        //todo: check whether an equivalent rule is already present?\r\n        var cnt = rules.length;\r\n        insertRuleIfNotPresent(rules, newRule, seenRules);\r\n    })\r\n}\r\n\r\n\r\nexport function addCloseExactRangeRules(rules: IMatch.mRule[], seenRules) {\r\n    var keysMap = {} as { [key: string]: IMatch.mRule[] };\r\n    var rangeKeysMap = {} as { [key: string]: IMatch.mRule[] };\r\n    rules.forEach(rule => {\r\n        if (rule.type === IMatch.EnumRuleType.WORD) {\r\n            //keysMap[rule.lowercaseword] = 1;\r\n            keysMap[rule.lowercaseword] = keysMap[rule.lowercaseword] || [];\r\n            keysMap[rule.lowercaseword].push(rule);\r\n            if (!rule.exactOnly && rule.range) {\r\n                rangeKeysMap[rule.lowercaseword] = rangeKeysMap[rule.lowercaseword] || [];\r\n                rangeKeysMap[rule.lowercaseword].push(rule);\r\n            }\r\n        }\r\n    });\r\n    var keys = Object.keys(keysMap);\r\n    keys.sort(cmpLengthSort);\r\n    var len = 0;\r\n    keys.forEach((key, index) => {\r\n        if (key.length != len) {\r\n            //console.log(\"shift to len\" + key.length + ' at ' + index + ' ' + key );\r\n        }\r\n        len = key.length;\r\n    });\r\n    //   keys = keys.slice(0,2000);\r\n    var rangeKeys = Object.keys(rangeKeysMap);\r\n    rangeKeys.sort(cmpLengthSort);\r\n    //console.log(` ${keys.length} keys and ${rangeKeys.length} rangekeys `);\r\n    var low = 0;\r\n    var high = 0;\r\n    var lastlen = 0;\r\n    var offsets = [0, 0, 0, 0, 0, 0];\r\n    var len = rangeKeys.length;\r\n    findNextLen(0, keys, offsets);\r\n    findNextLen(1, keys, offsets);\r\n    findNextLen(2, keys, offsets);\r\n\r\n    rangeKeys.forEach(function (rangeKey) {\r\n        if (rangeKey.length !== lastlen) {\r\n            for (i = lastlen + 1; i <= rangeKey.length; ++i) {\r\n                findNextLen(i + 2, keys, offsets);\r\n            }\r\n            //   console.log(` shifted to ${rangeKey.length} with offsets beeing ${offsets.join(' ')}`);\r\n            //   console.log(` here 0 ${offsets[0]} : ${keys[Math.min(keys.length-1, offsets[0])].length}  ${keys[Math.min(keys.length-1, offsets[0])]} `);\r\n            //  console.log(` here 5-1  ${keys[offsets[5]-1].length}  ${keys[offsets[5]-1]} `);\r\n            //   console.log(` here 5 ${offsets[5]} : ${keys[Math.min(keys.length-1, offsets[5])].length}  ${keys[Math.min(keys.length-1, offsets[5])]} `);\r\n            lastlen = rangeKey.length;\r\n        }\r\n        for (var i = offsets[0]; i < offsets[5]; ++i) {\r\n            var d = Distance.calcDistanceAdjusted(rangeKey, keys[i]);\r\n            // console.log(`${rangeKey.length-keys[i].length} ${d} ${rangeKey} and ${keys[i]}  `);\r\n            if ((d !== 1.0) && (d >= Algol.Cutoff_rangeCloseMatch)) {\r\n                //console.log(`would add ${rangeKey} for ${keys[i]} ${d}`);\r\n                var cnt = rules.length;\r\n                // we only have to add if there is not yet a match rule here which points to the same\r\n                addRangeRulesUnlessPresent(rules, keys[i], rangeKeysMap[rangeKey], keysMap[keys[i]], seenRules);\r\n                if (rules.length > cnt) {\r\n                    //console.log(` added ${(rules.length - cnt)} records at${rangeKey} for ${keys[i]} ${d}`);\r\n                }\r\n\r\n            }\r\n        }\r\n    });\r\n    /*\r\n    [\r\n        ['aEFG','aEFGH'],\r\n        ['aEFGH','aEFGHI'],\r\n        ['Odata','ODatas'],\r\n   ['Odata','Odatas'],\r\n   ['Odata','Odatb'],\r\n   ['Odata','UData'],\r\n   ['service','services'],\r\n   ['this isfunny and more','this isfunny and mores'],\r\n    ].forEach(rec => {\r\n        console.log(`distance ${rec[0]} ${rec[1]} : ${Distance.calcDistance(rec[0],rec[1])}  adf ${Distance.calcDistanceAdjusted(rec[0],rec[1])} `);\r\n\r\n    });\r\n    console.log(\"distance Odata Udata\"+ Distance.calcDistance('OData','UData'));\r\n    console.log(\"distance Odata Odatb\"+ Distance.calcDistance('OData','ODatb'));\r\n    console.log(\"distance Odatas Odata\"+ Distance.calcDistance('OData','ODataa'));\r\n    console.log(\"distance Odatas abcde\"+ Distance.calcDistance('abcde','abcdef'));\r\n    console.log(\"distance services \"+ Distance.calcDistance('services','service'));\r\n    */\r\n}\r\nvar n = 0;\r\n\r\n\r\nexport function readFillers(mongoose : mongoose.Mongoose, oModel : IMatch.IModels)  : Promise<any> {\r\n    var fillerBitIndex = getDomainBitIndex('meta', oModel);\r\n    var bitIndexAllDomains = getAllDomainsBitIndex(oModel);\r\n    return Schemaload.getFillersFromDB(mongoose).then(\r\n        (fillersObj) => fillersObj.fillers\r\n    ).then((fillers: string[]) => {\r\n        //  fillersreadFileAsJSON('./' + modelPath + '/filler.json');\r\n        /*\r\n        var re = \"^((\" + fillers.join(\")|(\") + \"))$\";\r\n        oModel.mRules.push({\r\n            category: \"filler\",\r\n            type: IMatch.EnumRuleType.REGEXP,\r\n            regexp: new RegExp(re, \"i\"),\r\n            matchedString: \"filler\",\r\n            bitindex: fillerBitIndex,\r\n            _ranking: 0.9\r\n        });\r\n        */\r\n        if (!_.isArray(fillers)) {\r\n            throw new Error('expect fillers to be an array of strings');\r\n        }\r\n        fillers.forEach(filler => {\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"filler\",\r\n                type: IMatch.EnumRuleType.WORD,\r\n                word: filler,\r\n                lowercaseword: filler.toLowerCase(),\r\n                matchedString: filler, //\"filler\",\r\n                exactOnly: true,\r\n                bitindex: fillerBitIndex,\r\n                bitSentenceAnd: bitIndexAllDomains,\r\n                wordType: IMatch.WORDTYPE.FILLER,\r\n                _ranking: 0.9\r\n            }, oModel.seenRules);\r\n        });\r\n        return true;\r\n    });\r\n};\r\n\r\n\r\nexport function readOperators(mongoose: mongoose.Mongoose, oModel: IMatch.IModels) : Promise<any> {\r\n        debuglog('reading operators');\r\n        //add operators\r\n    return Schemaload.getOperatorsFromDB(mongoose).then(\r\n        (operators: any) => {\r\n        var operatorBitIndex = getDomainBitIndex('operators', oModel);\r\n        var bitIndexAllDomains = getAllDomainsBitIndex(oModel);\r\n        Object.keys(operators.operators).forEach(function (operator) {\r\n            if (IMatch.aOperatorNames.indexOf(operator) < 0) {\r\n                debuglog(\"unknown operator \" + operator);\r\n                throw new Error(\"unknown operator \" + operator);\r\n            }\r\n            oModel.operators[operator] = operators.operators[operator];\r\n            oModel.operators[operator].operator = <IMatch.OperatorName>operator;\r\n            Object.freeze(oModel.operators[operator]);\r\n            var word = operator;\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"operator\",\r\n                word: word.toLowerCase(),\r\n                lowercaseword: word.toLowerCase(),\r\n                type: IMatch.EnumRuleType.WORD,\r\n                matchedString: word,\r\n                bitindex: operatorBitIndex,\r\n                bitSentenceAnd: bitIndexAllDomains,\r\n                wordType: IMatch.WORDTYPE.OPERATOR,\r\n                _ranking: 0.9\r\n            }, oModel.seenRules);\r\n            // add all synonyms\r\n            if (operators.synonyms[operator]) {\r\n                var arr = operators.synonyms[operator];\r\n                if ( arr )\r\n                {\r\n\r\n                    if( Array.isArray(arr))\r\n                    {\r\n                        arr.forEach(function (synonym) {\r\n                            insertRuleIfNotPresent(oModel.mRules, {\r\n                                category: \"operator\",\r\n                                word: synonym.toLowerCase(),\r\n                                lowercaseword: synonym.toLowerCase(),\r\n                                type: IMatch.EnumRuleType.WORD,\r\n                                matchedString: operator,\r\n                                bitindex: operatorBitIndex,\r\n                                bitSentenceAnd: bitIndexAllDomains,\r\n                                wordType: IMatch.WORDTYPE.OPERATOR,\r\n                                _ranking: 0.9\r\n                            }, oModel.seenRules);\r\n                        });\r\n                    } else\r\n                    {\r\n                        throw Error(\"Expeted operator synonym to be array \" + operator + \" is \" + JSON.stringify(arr));\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        return true;\r\n    });\r\n};\r\n\r\nexport function releaseModel(model : IMatch.IModels) {\r\n    if(model.mongoHandle && model.mongoHandle.mongoose) {\r\n        MongoUtils.disconnect(model.mongoHandle.mongoose);\r\n    }\r\n}\r\n/*\r\nexport function loadModelHandleP(mongooseHndl : mongoose.Mongoose, modelPath: string, connectionString? : string) : Promise<IMatch.IModels> {\r\n    var mongooseX = mongooseHndl || mongoose;\r\n //   if(process.env.MONGO_REPLAY) {\r\n //        mongooseX = mongooseMock.mongooseMock as any;\r\n //    }\r\n    var connStr = connectionString || 'mongodb://localhost/testdb';\r\n    return MongoUtils.openMongoose(mongooseX, connStr).then(\r\n        () => getMongoHandle(mongooseX)\r\n    ).then( (modelHandle : IMatch.IModelHandleRaw) => loadModelsFull(modelHandle, modelPath));\r\n};\r\n*/\r\n\r\nexport function loadModelsOpeningConnection(mongooseHndl: mongoose.Mongoose, connectionString? : string,  modelPath? : string) : Promise<void | IMatch.IModels> {\r\n  var mongooseX = mongooseHndl || mongoose;\r\n //   if(process.env.MONGO_REPLAY) {\r\n //        mongooseX = mongooseMock.mongooseMock as any;\r\n //    }\r\n    console.log(\" explicit connection string \" + connectionString);\r\n    var connStr = connectionString || 'mongodb://localhost/testdb';\r\n    return MongoUtils.openMongoose(mongooseX, connStr).then(\r\n        ()=>\r\n        {\r\n            return loadModels(mongooseX, modelPath);\r\n        }\r\n    );\r\n}\r\n\r\n/**\r\n * expects an open connection!\r\n * @param mongoose\r\n * @param modelPath\r\n */\r\nexport function loadModels(mongoose: mongoose.Mongoose, modelPath : string) : Promise<void | IMatch.IModels> {\r\n    if(mongoose === undefined) {\r\n        throw new Error('expect a mongoose handle to be passed');\r\n    }\r\n    return getMongoHandle(mongoose).then( (modelHandle) =>{\r\n        debuglog(`got a mongo handle for ${modelPath}`);\r\n        return _loadModelsFull(modelHandle, modelPath);\r\n    });\r\n}\r\n\r\nexport function _loadModelsFull(modelHandle: IMatch.IModelHandleRaw, modelPath?: string): Promise<void | IMatch.IModels> {\r\n    var oModel: IMatch.IModels;\r\n    modelPath = modelPath || envModelPath;\r\n    modelHandle = modelHandle || {\r\n        mongoose: undefined,\r\n        modelDocs: {},\r\n        mongoMaps: {},\r\n        modelESchemas: {}\r\n    };\r\n    oModel = {\r\n        mongoHandle : modelHandle,\r\n        full: { domain: {} },\r\n        rawModels: {},\r\n        domains: [],\r\n        rules: undefined,\r\n        category: [],\r\n        operators: {},\r\n        mRules: [],\r\n        seenRules: {},\r\n        meta: { t3: {} }\r\n    }\r\n    var t = Date.now();\r\n\r\n    try {\r\n        debuglog(()=> 'here model path' + modelPath);\r\n        var a = CircularSer.load(modelPath + '/_cache.js');\r\n        // TODO\r\n        //console.log(\"found a cache ?  \" + !!a);\r\n        //a = undefined;\r\n        if (a && !process.env.MGNLQ_MODEL_NO_FILECACHE) {\r\n            //console.log('return preps' + modelPath);\r\n            debuglog(\"\\n return prepared model !!\");\r\n            if (process.env.ABOT_EMAIL_USER) {\r\n                console.log(\"loaded models from cache in \" + (Date.now() - t) + \" \");\r\n            }\r\n            var res = a;\r\n            res.mongoHandle.mongoose  = modelHandle.mongoose;\r\n            return Promise.resolve(res);\r\n        }\r\n    } catch (e) {\r\n        //console.log('error' + e);\r\n        // no cache file,\r\n    }\r\n    //var mdls = readFileAsJSON('./' + modelPath + '/models.json');\r\n\r\n    var mdls = Object.keys(modelHandle.modelDocs).sort();\r\n    var seenDomains ={};\r\n    mdls.forEach((modelName,index) => {\r\n        var domain = modelHandle.modelDocs[modelName].domain;\r\n        if(seenDomains[domain]) {\r\n            throw new Error('Domain ' + domain + ' already loaded while loading ' + modelName + '?');\r\n        }\r\n        seenDomains[domain] = index;\r\n    })\r\n    oModel.domains = mdls.map(modelName => modelHandle.modelDocs[modelName].domain);\r\n    // create bitindex in order !\r\n    debuglog('got domains ' + mdls.join(\"\\n\"));\r\n    debuglog('loading models ' + mdls.join(\"\\n\"));\r\n\r\n    return Promise.all(mdls.map((sModelName) =>\r\n        loadModel(modelHandle, sModelName, oModel))\r\n    ).then(() => {\r\n        var metaBitIndex = getDomainBitIndex('meta', oModel);\r\n        var bitIndexAllDomains = getAllDomainsBitIndex(oModel);\r\n\r\n        // add the domain meta rule\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"meta\",\r\n            matchedString: \"domain\",\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: \"domain\",\r\n            bitindex: metaBitIndex,\r\n            wordType: IMatch.WORDTYPE.META,\r\n            bitSentenceAnd: bitIndexAllDomains,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n        // insert the Numbers rules\r\n        console.log(' add numbers rule');\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"number\",\r\n            matchedString: \"one\",\r\n            type: IMatch.EnumRuleType.REGEXP,\r\n            regexp : /^((\\d+)|(one)|(two)|(three))$/,\r\n            matchIndex : 0,\r\n            word: \"<number>\",\r\n            bitindex: metaBitIndex,\r\n            wordType: IMatch.WORDTYPE.NUMERICARG, // number\r\n            bitSentenceAnd: bitIndexAllDomains,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n\r\n        return true;\r\n    }\r\n    ).then( ()=>\r\n        readFillers(modelHandle.mongoose, oModel)\r\n    ).then( () =>\r\n        readOperators(modelHandle.mongoose, oModel)\r\n    ).then( () => {\r\n        /*\r\n            })\r\n                {\r\n              category: \"filler\",\r\n              type: 1,\r\n              regexp: /^((start)|(show)|(from)|(in))$/i,\r\n              matchedString: \"filler\",\r\n              _ranking: 0.9\r\n            },\r\n        */\r\n        debuglog('saving data to ' + modelPath);\r\n        oModel.mRules = oModel.mRules.sort(InputFilterRules.cmpMRule);\r\n        addCloseExactRangeRules(oModel.mRules, oModel.seenRules);\r\n        oModel.mRules = oModel.mRules.sort(InputFilterRules.cmpMRule);\r\n        oModel.mRules.sort(InputFilterRules.cmpMRule);\r\n        //fs.writeFileSync(\"post_sort\", JSON.stringify(oModel.mRules,undefined,2));\r\n\r\n        forceGC();\r\n        oModel.rules = splitRules(oModel.mRules);\r\n        fs.writeFileSync(\"test1x.json\", JSON.stringify(oModel.rules,undefined,2));\r\n        forceGC();\r\n        delete oModel.seenRules;\r\n        debuglog('saving');\r\n        forceGC();\r\n        var oModelSer = Object.assign({}, oModel);\r\n        oModelSer.mongoHandle = Object.assign({}, oModel.mongoHandle);\r\n        delete oModelSer.mongoHandle.mongoose;\r\n        CircularSer.save(modelPath + '/_cache.js', oModelSer);\r\n        forceGC();\r\n        if (process.env.ABOT_EMAIL_USER) {\r\n            console.log(\"loaded models by calculation in \" + (Date.now() - t) + \" \");\r\n        }\r\n\r\n        var res = oModel;\r\n        // (Object as any).assign(modelHandle, { model: oModel }) as IMatch.IModelHandle;\r\n\r\n        return res;\r\n    }\r\n    ).catch( (err) => {\r\n        console.log(err + ' ' + err.stack);\r\n        process.exit(-1);\r\n    })\r\n}\r\n\r\nexport function sortCategoriesByImportance(map: { [key: string]: IMatch.ICategoryDesc }, cats: string[]): string[] {\r\n    var res = cats.slice(0);\r\n    res.sort(rankCategoryByImportance.bind(undefined, map));\r\n    return res;\r\n}\r\n\r\nexport function rankCategoryByImportance(map: { [key: string]: IMatch.ICategoryDesc }, cata: string, catb: string): number {\r\n    var catADesc = map[cata];\r\n    var catBDesc = map[catb];\r\n    if (cata === catb) {\r\n        return 0;\r\n    }\r\n    // if a is before b, return -1\r\n    if (catADesc && !catBDesc) {\r\n        return -1;\r\n    }\r\n    if (!catADesc && catBDesc) {\r\n        return +1;\r\n    }\r\n\r\n    var prioA = (catADesc && catADesc.importance) || 99;\r\n    var prioB = (catBDesc && catBDesc.importance) || 99;\r\n    // lower prio goes to front\r\n    var r = prioA - prioB;\r\n    if (r) {\r\n        return r;\r\n    }\r\n    return cata.localeCompare(catb);\r\n}\r\n\r\nconst MetaF = Meta.getMetaFactory();\r\n\r\nexport function getOperator(mdl: IMatch.IModels, operator: string): IMatch.IOperator {\r\n    return mdl.operators[operator];\r\n}\r\n\r\nexport function getResultAsArray(mdl: IMatch.IModels, a: Meta.IMeta, rel: Meta.IMeta): Meta.IMeta[] {\r\n    if (rel.toType() !== 'relation') {\r\n        throw new Error(\"expect relation as 2nd arg\");\r\n    }\r\n\r\n    var res = mdl.meta.t3[a.toFullString()] &&\r\n        mdl.meta.t3[a.toFullString()][rel.toFullString()];\r\n    if (!res) {\r\n        return [];\r\n    }\r\n    return Object.getOwnPropertyNames(res).sort().map(MetaF.parseIMeta);\r\n}\r\n\r\nexport function checkDomainPresent(theModel: IMatch.IModels, domain: string) {\r\n    if (theModel.domains.indexOf(domain) < 0) {\r\n        throw new Error(\"Domain \\\"\" + domain + \"\\\" not part of model\");\r\n    }\r\n}\r\n\r\nexport function getShowURICategoriesForDomain(theModel : IMatch.IModels, domain : string) : string[] {\r\n    checkDomainPresent(theModel, domain);\r\n    var modelName = getModelNameForDomain(theModel.mongoHandle,domain);\r\n    var allcats = getResultAsArray(theModel, MetaF.Domain(domain), MetaF.Relation(Meta.RELATION_hasCategory));\r\n    var doc = theModel.mongoHandle.modelDocs[modelName];\r\n    var res = doc._categories.filter( cat => cat.showURI ).map(cat => cat.category);\r\n    return res;\r\n}\r\n\r\nexport function getShowURIRankCategoriesForDomain(theModel : IMatch.IModels, domain : string) : string[] {\r\n    checkDomainPresent(theModel, domain);\r\n    var modelName = getModelNameForDomain(theModel.mongoHandle,domain);\r\n    var allcats = getResultAsArray(theModel, MetaF.Domain(domain), MetaF.Relation(Meta.RELATION_hasCategory));\r\n    var doc = theModel.mongoHandle.modelDocs[modelName];\r\n    var res = doc._categories.filter( cat => cat.showURIRank ).map(cat => cat.category);\r\n    return res;\r\n}\r\n\r\nexport function getCategoriesForDomain(theModel: IMatch.IModels, domain: string): string[] {\r\n    checkDomainPresent(theModel, domain);\r\n    var res = getResultAsArray(theModel, MetaF.Domain(domain), MetaF.Relation(Meta.RELATION_hasCategory));\r\n    return Meta.getStringArray(res);\r\n}\r\n\r\nexport function getTableColumns(theModel: IMatch.IModels, domain: string): string[] {\r\n    checkDomainPresent(theModel, domain);\r\n    return theModel.rawModels[domain].columns.slice(0);\r\n}\r\n\r\nfunction forceGC() {\r\n    if (global && global.gc) {\r\n        global.gc();\r\n    }\r\n}\r\n\r\n/**\r\n * Return all categories of a domain which can appear on a word,\r\n * these are typically the wordindex domains + entries generated by generic rules\r\n *\r\n * The current implementation is a simplification\r\n */\r\nexport function getPotentialWordCategoriesForDomain(theModel: IMatch.IModels, domain: string): string[] {\r\n    // this is a simplified version\r\n    return getCategoriesForDomain(theModel, domain);\r\n}\r\n\r\nexport function getDomainsForCategory(theModel: IMatch.IModels, category: string): string[] {\r\n    if (theModel.category.indexOf(category) < 0) {\r\n        throw new Error(\"Category \\\"\" + category + \"\\\" not part of model\");\r\n    }\r\n    var res = getResultAsArray(theModel, MetaF.Category(category), MetaF.Relation(Meta.RELATION_isCategoryOf));\r\n    return Meta.getStringArray(res);\r\n}\r\n\r\n/*\r\nexport function getAllRecordCategoriesForTargetCategory(model: IMatch.IModels, category: string, wordsonly: boolean): { [key: string]: boolean } {\r\n    var res = {};\r\n    //\r\n    var fn = wordsonly ? getPotentialWordCategoriesForDomain : getCategoriesForDomain;\r\n    var domains = getDomainsForCategory(model, category);\r\n    domains.forEach(function (domain) {\r\n        fn(model, domain).forEach(function (wordcat) {\r\n            res[wordcat] = true;\r\n        });\r\n    });\r\n    Object.freeze(res);\r\n    return res;\r\n}\r\n\r\nexport function getAllRecordCategoriesForTargetCategories(model: IMatch.IModels, categories: string[], wordsonly: boolean): { [key: string]: boolean } {\r\n    var res = {};\r\n    //\r\n    var fn = wordsonly ? getPotentialWordCategoriesForDomain : getCategoriesForDomain;\r\n    var domains = undefined;\r\n    categories.forEach(function (category) {\r\n        var catdomains = getDomainsForCategory(model, category)\r\n        if (!domains) {\r\n            domains = catdomains;\r\n        } else {\r\n            domains = _.intersection(domains, catdomains);\r\n        }\r\n    });\r\n    if (domains.length === 0) {\r\n        throw new Error('categories ' + Utils.listToQuotedCommaAnd(categories) + ' have no common domain.')\r\n    }\r\n    domains.forEach(function (domain) {\r\n        fn(model, domain).forEach(function (wordcat) {\r\n            res[wordcat] = true;\r\n        });\r\n    });\r\n    Object.freeze(res);\r\n    return res;\r\n}\r\n*/\r\n\r\n/**\r\n * givena  set  of categories, return a structure\r\n *\r\n *\r\n * { domains : [\"DOMAIN1\", \"DOMAIN2\"],\r\n *   categorySet : {   cat1 : true, cat2 : true, ...}\r\n * }\r\n */\r\nexport function getDomainCategoryFilterForTargetCategories(model: IMatch.IModels, categories: string[], wordsonly: boolean): IMatch.IDomainCategoryFilter {\r\n    var res = {};\r\n    //\r\n    var fn = wordsonly ? getPotentialWordCategoriesForDomain : getCategoriesForDomain;\r\n    var domains = undefined as string[];\r\n    categories.forEach(function (category) {\r\n        var catdomains = getDomainsForCategory(model, category)\r\n        if (!domains) {\r\n            domains = catdomains;\r\n        } else {\r\n            domains = _.intersection(domains, catdomains);\r\n        }\r\n    });\r\n    if (domains.length === 0) {\r\n        throw new Error('categories ' + Utils.listToQuotedCommaAnd(categories) + ' have no common domain.')\r\n    }\r\n    domains.forEach(function (domain) {\r\n        fn(model, domain).forEach(function (wordcat) {\r\n            res[wordcat] = true;\r\n        });\r\n    });\r\n    Object.freeze(res);\r\n    return {\r\n        domains: domains,\r\n        categorySet: res\r\n    };\r\n}\r\n\r\n\r\nexport function getDomainCategoryFilterForTargetCategory(model: IMatch.IModels, category: string, wordsonly: boolean): IMatch.IDomainCategoryFilter {\r\n    return getDomainCategoryFilterForTargetCategories(model, [category], wordsonly);\r\n}\r\n\r\n\r\n"],"sourceRoot":"ABC"}