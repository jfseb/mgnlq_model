{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_model/src/../src/model/model.ts"],"names":[],"mappings":"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","file":"model/model.js","sourcesContent":["/**\r\n * Functionality managing the match models\r\n *\r\n * @file\r\n */\r\n\r\n//import * as intf from 'constants';\r\nimport * as debugf from 'debugf';\r\n\r\nvar debuglog = debugf('model');\r\n\r\n//const loadlog = logger.logger('modelload', '');\r\n\r\nimport *  as IMatch from '../match/ifmatch';\r\nimport * as InputFilterRules from '../match/rule';\r\n//import * as Tools from '../match/tools';\r\nimport * as fs from 'fs';\r\nimport * as Meta from './meta';\r\nimport * as Utils from 'abot_utils';\r\nimport * as CircularSer from 'abot_utils';\r\nimport * as Distance from 'abot_stringdist';\r\nimport * as process from 'process';\r\nimport * as _ from 'lodash';\r\n\r\nimport * as MongoUtils from '../utils/mongo';\r\n\r\nimport * as mongoose from 'mongoose';\r\nimport * as ISchema from '../modelload/schemaload';\r\nimport * as Schemaload from '../modelload/schemaload';\r\nimport * as MongoMap from './mongomap';\r\n\r\nimport * as mongooseMock from 'mongoose_record_replay';\r\n\r\n/**\r\n * the model path, may be controlled via environment variable\r\n */\r\nvar envModelPath = process.env[\"ABOT_MODELPATH\"] || \"node_modules/mgnlq_testmodel/testmodel\";\r\n\r\n\r\nexport function cmpTools(a: IMatch.ITool, b: IMatch.ITool) {\r\n    return a.name.localeCompare(b.name);\r\n}\r\n\r\n\r\ntype IModel = IMatch.IModel;\r\n\r\n\r\n/**\r\n * returns when all models are loaded and all modeldocs are made\r\n * @param mongoose\r\n */\r\nexport function getMongoHandle(mongoose: mongoose.Mongoose): Promise<IMatch.IModelHandleRaw> {\r\n    var res = {\r\n        mongoose: mongoose,\r\n        modelDocs: {},\r\n        modelESchemas: {},\r\n        mongoMaps: {}\r\n    } as IMatch.IModelHandleRaw;\r\n    var modelES = Schemaload.getExtendedSchemaModel(mongoose);\r\n    return modelES.distinct('modelname').then((modelnames) => {\r\n        debuglog(() => 'here distinct modelnames ' + JSON.stringify(modelnames));\r\n        return Promise.all(modelnames.map(function (modelname) {\r\n            debuglog(() => 'creating tripel for ' + modelname);\r\n            return Promise.all([Schemaload.getExtendSchemaDocFromDB(mongoose, modelname),\r\n            Schemaload.makeModelFromDB(mongoose, modelname),\r\n            Schemaload.getModelDocFromDB(mongoose, modelname)]).then(\r\n                (value) => {\r\n                    debuglog(() => 'attempting to load ' + modelname);\r\n                    var [extendedSchema, model, modelDoc] = value;\r\n                    res.modelESchemas[modelname] = extendedSchema;\r\n                    res.modelDocs[modelname] = modelDoc;\r\n                    res.mongoMaps[modelname] = MongoMap.makeMongoMap(modelDoc, extendedSchema)\r\n                }\r\n                )\r\n        }));\r\n    }).then(() => {\r\n        return res;\r\n    })\r\n    //var modelDoc = Schemaload.getExtendedDocModel(mongoose);\r\n    //res.modelDocs[ISchema.MongoNLQ.MODELNAME_METAMODELS] = modelDoc;\r\n    //return Promise.resolve(res);\r\n}\r\n\r\nexport function getFactSynonyms(mongoHandle: IMatch.IModelHandleRaw, modelname: string): Promise<ISynonym[]> {\r\n    var model = mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n    //     return model.find( { \"_synonyms.0\" : { $exists: false}}).lean().exec();\r\n    return model.aggregate({ $match: { \"_synonyms.0\": { $exists: true } } },\r\n        { $project: { _synonyms: 1 } },\r\n        { $unwind: \"$_synonyms\" },\r\n        { $project: { \"category\": \"$_synonyms.category\", \"fact\": \"$_synonyms.fact\", \"synonyms\": \"$_synonyms.synonyms\" } }).exec();\r\n\r\n}\r\n\r\nexport interface ISynonym {\r\n    category: string,\r\n    fact: string,\r\n    synonyms: string[]\r\n};\r\n\r\nexport interface ISynonymBearingDoc {\r\n    _synonyms: [{\r\n        category: string,\r\n        fact: string,\r\n        synonyms: string[]\r\n    }]\r\n}\r\n\r\n// db.cosmos.aggregate({$match : { \"_synonyms.0\": { $exists: true}}}, { $project : { _synonyms : 1}}, { $unwind : \"$_synonyms\"});\r\n\r\nexport function remapSynonyms(docs: ISynonymBearingDoc[]): ISynonym[] {\r\n    return docs.reduce((prev, doc) => {\r\n        doc._synonyms.forEach(syn =>\r\n            prev.push({\r\n                category: syn.category,\r\n                fact: syn.fact,\r\n                synonyms: syn.synonyms\r\n            })\r\n        );\r\n        return prev;\r\n    }\r\n        , [] as ISynonym[]);\r\n}\r\n\r\n// get synonyms\r\n// db.cosmos.find( { \"_synonyms.0\": { $exists: true }}).length()\r\n\r\nexport function getDistinctValues(mongoHandle: IMatch.IModelHandleRaw, modelname: string, category: string): Promise<string[]> {\r\n    debuglog(() => `here models ${modelname} ` + mongoHandle.mongoose.modelNames().join(';'));\r\n    var model = mongoHandle.mongoose.model(Schemaload.makeMongooseModelName(modelname));\r\n    var mongoMap = mongoHandle.mongoMaps[modelname];\r\n    if (!model) {\r\n        debuglog(' no model for ' + modelname);\r\n        return Promise.reject(`model ${modelname} not found in db`);\r\n    }\r\n    if (!mongoMap) {\r\n        debuglog(' no mongoMap for ' + modelname);\r\n        return Promise.reject(`model ${modelname} has no modelmap`);\r\n    }\r\n    if (!mongoMap[category]) {\r\n        debuglog(' no mongoMap category for ' + modelname);\r\n        return Promise.reject(`model ${modelname} has no category ${category}`);\r\n    }\r\n    debuglog(' here path for distinct value ' + mongoMap[category].fullpath );\r\n    return model.distinct(mongoMap[category].fullpath).then(res => {\r\n        debuglog(() => ` here res for ${modelname}  ${category} values ` + JSON.stringify(res, undefined, 2));\r\n        return res;\r\n    });\r\n}\r\n\r\nconst ARR_MODEL_PROPERTIES = [\"domain\", \"bitindex\", \"defaultkeycolumn\", \"defaulturi\", \"categoryDescribed\", \"columns\", \"description\", \"tool\", \"toolhidden\", \"synonyms\", \"category\", \"wordindex\", \"exactmatch\", \"hidden\"];\r\n\r\nfunction addSynonyms(synonyms: string[], category: string, synonymFor: string, bitindex: number, bitSentenceAnd,\r\n    wordType: string,\r\n    mRules: Array<IMatch.mRule>, seen: { [key: string]: IMatch.mRule[] }) {\r\n    synonyms.forEach(function (syn) {\r\n        var oRule = {\r\n            category: category,\r\n            matchedString: synonymFor,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: syn,\r\n            bitindex: bitindex,\r\n            bitSentenceAnd: bitSentenceAnd,\r\n            wordType: wordType,\r\n            _ranking: 0.95\r\n        };\r\n        debuglog(debuglog.enabled ? (\"inserting synonym\" + JSON.stringify(oRule)) : '-');\r\n        insertRuleIfNotPresent(mRules, oRule, seen);\r\n    });\r\n}\r\n\r\nfunction getRuleKey(rule) {\r\n    var r1 = rule.matchedString + \"-|-\" + rule.category + \" -|- \" + rule.type + \" -|- \" + rule.word + \" \" + rule.bitindex + \" \" + rule.wordType;\r\n    if (rule.range) {\r\n        var r2 = getRuleKey(rule.range.rule);\r\n        r1 += \" -|- \" + rule.range.low + \"/\" + rule.range.high + \" -|- \" + r2;\r\n    }\r\n    return r1;\r\n}\r\n\r\n\r\nimport * as Breakdown from '../match/breakdown';\r\n\r\n/* given a rule which represents a word sequence which is split during tokenization */\r\nexport function addBestSplit(mRules: Array<IMatch.mRule>, rule: IMatch.mRule, seenRules: { [key: string]: IMatch.mRule[] }) {\r\n    //if(!global_AddSplits) {\r\n    //    return;\r\n    //}\r\n\r\n    if (rule.type !== IMatch.EnumRuleType.WORD) {\r\n        return;\r\n    }\r\n    var best = Breakdown.makeMatchPattern(rule.lowercaseword);\r\n    if (!best) {\r\n        return;\r\n    }\r\n    var newRule = {\r\n        category: rule.category,\r\n        matchedString: rule.matchedString,\r\n        bitindex: rule.bitindex,\r\n        bitSentenceAnd: rule.bitindex,\r\n        wordType: rule.wordType,\r\n        word: best.longestToken,\r\n        type: 0,\r\n        lowercaseword: best.longestToken,\r\n        _ranking: 0.95,\r\n        //    exactOnly : rule.exactOnly,\r\n        range: best.span\r\n    } as IMatch.mRule;\r\n    if (rule.exactOnly) {\r\n        newRule.exactOnly = rule.exactOnly\r\n    };\r\n    newRule.range.rule = rule;\r\n    insertRuleIfNotPresent(mRules, newRule, seenRules);\r\n}\r\n\r\n\r\nfunction insertRuleIfNotPresent(mRules: Array<IMatch.mRule>, rule: IMatch.mRule,\r\n    seenRules: { [key: string]: IMatch.mRule[] }) {\r\n\r\n    if (rule.type !== IMatch.EnumRuleType.WORD) {\r\n        debuglog('not a  word return fast '+ rule.matchedString);\r\n        mRules.push(rule);\r\n        return;\r\n    }\r\n    if ((rule.word === undefined) || (rule.matchedString === undefined)) {\r\n        throw new Error('illegal rule' + JSON.stringify(rule, undefined, 2));\r\n    }\r\n    var r = getRuleKey(rule);\r\n    /* if( (rule.word === \"service\" || rule.word=== \"services\") && r.indexOf('OData') >= 0) {\r\n         console.log(\"rulekey is\" + r);\r\n         console.log(\"presence is \" + JSON.stringify(seenRules[r]));\r\n     }*/\r\n    rule.lowercaseword = rule.word.toLowerCase();\r\n    if (seenRules[r]) {\r\n        debuglog(() => (\"Attempting to insert duplicate\" + JSON.stringify(rule, undefined, 2) + \" : \" + r));\r\n        var duplicates = seenRules[r].filter(function (oEntry) {\r\n            return 0 === InputFilterRules.compareMRuleFull(oEntry, rule);\r\n        });\r\n        if (duplicates.length > 0) {\r\n            return;\r\n        }\r\n    }\r\n    seenRules[r] = (seenRules[r] || []);\r\n    seenRules[r].push(rule);\r\n    if (rule.word === \"\") {\r\n        debuglog(debuglog.enabled ? ('Skipping rule with emtpy word ' + JSON.stringify(rule, undefined, 2)) : '-');\r\n        //g('Skipping rule with emtpy word ' + JSON.stringify(rule, undefined, 2));\r\n        return;\r\n    }\r\n    mRules.push(rule);\r\n    addBestSplit(mRules, rule, seenRules);\r\n    return;\r\n}\r\n\r\nexport function readFileAsJSON(filename: string): any {\r\n    var data = fs.readFileSync(filename, 'utf-8');\r\n    try {\r\n        return JSON.parse(data);\r\n    } catch (e) {\r\n        console.log(\"Content of file \" + filename + \" is no json\" + e);\r\n        process.exit(-1);\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/*\r\nfunction loadModelData1(modelPath: string, oMdl: IModel, sModelName: string, oModel: IMatch.IModels) {\r\n    // read the data ->\r\n    // data is processed into mRules directly,\r\n\r\n    var bitindex = oMdl.bitindex;\r\n    const sFileName = ('./' + modelPath + '/' + sModelName + \".data.json\");\r\n    var oMdlData= readFileAsJSON(sFileName);\r\n    oMdlData.forEach(function (oEntry) {\r\n        if (!oEntry.domain) {\r\n            oEntry._domain = oMdl.domain;\r\n        }\r\n        if (!oEntry.tool && oMdl.tool.name) {\r\n            oEntry.tool = oMdl.tool.name;\r\n        }\r\n        oModel.records.push(oEntry);\r\n        oMdl.category.forEach(function (cat) {\r\n            if (oEntry[cat] === 'undefined') {\r\n                oEntry[cat] = \"n/a\";\r\n                var bug =\r\n                    \"INCONSISTENT*> ModelData \" + sFileName + \" does not contain category \" + cat + \" with value 'undefined', undefined is illegal value, use n/a \" + JSON.stringify(oEntry) + \"\";\r\n                debuglog(bug);\r\n                //console.log(bug);\r\n                //process.exit(-1);\r\n            }\r\n        })\r\n\r\n        oMdl.wordindex.forEach(function (category) {\r\n            if (oEntry[category] === undefined) {\r\n                debuglog(\"INCONSISTENT*> ModelData \" + sFileName + \" does not contain category \" + category + \" of wordindex\" + JSON.stringify(oEntry) + \"\")\r\n                return;\r\n            }\r\n            if (oEntry[category] !== \"*\") {\r\n                var sString = oEntry[category];\r\n                debuglog(\"pushing rule with \" + category + \" -> \" + sString);\r\n                var oRule = {\r\n                    category: category,\r\n                    matchedString: sString,\r\n                    type: IMatch.EnumRuleType.WORD,\r\n                    word: sString,\r\n                    bitindex: bitindex,\r\n                    bitSentenceAnd : bitindex,\r\n                    wordType : IMatch.WORDTYPE.FACT,\r\n                    _ranking: 0.95\r\n                } as IMatch.mRule;\r\n                if (oMdl.exactmatch && oMdl.exactmatch.indexOf(category) >= 0) {\r\n                    oRule.exactOnly = true;\r\n                }\r\n                insertRuleIfNotPresent(oModel.mRules, oRule, oModel.seenRules);\r\n                if (oMdlData.synonyms && oMdlData.synonyms[category]) {\r\n                    throw new Error(\"how can this happen?\");\r\n                    //addSynonyms(oMdlData.synonyms[category], category, sString, bitindex, bitindex, \"X\", oModel.mRules, oModel.seenRules);\r\n                }\r\n                // a synonym for a FACT\r\n                if (oEntry.synonyms && oEntry.synonyms[category]) {\r\n                    addSynonyms(oEntry.synonyms[category], category, sString, bitindex, bitindex, IMatch.WORDTYPE.FACT, oModel.mRules, oModel.seenRules);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n*/\r\nexport function hasRuleWithFact(mRules : IMatch.mRule[], fact: string, category: string, bitindex: number) {\r\n    // TODO BAD QUADRATIC\r\n    return mRules.find( rule => {\r\n        return rule.word === fact && rule.category === category && rule.bitindex === bitindex\r\n    }) !== undefined;\r\n}\r\n\r\nfunction loadModelDataMongo(modelHandle: IMatch.IModelHandleRaw, oMdl: IModel, sModelName: string, oModel: IMatch.IModels): Promise<any> {\r\n    // read the data ->\r\n    // data is processed into mRules directly\r\n\r\n    var bitindex = oMdl.bitindex;\r\n    //const sFileName = ('./' + modelPath + '/' + sModelName + \".data.json\");\r\n    return Promise.all(modelHandle.modelDocs[sModelName]._categories.map(\r\n        categoryRec => {\r\n            var category = categoryRec.category;\r\n            var wordindex = categoryRec.wordindex;\r\n            if (!wordindex) {\r\n                return Promise.resolve(true);\r\n            }\r\n            else {\r\n                debuglog(() => 'adding values for ' + sModelName + ' ' +  category);\r\n                return getDistinctValues(modelHandle, sModelName, category).then(\r\n                    (values) => {\r\n                        debuglog(`found ${values.length} values for ${sModelName} ${category} `);\r\n                        values.map(value => {\r\n                            var sString = \"\" + value;\r\n                            debuglog(() => \"pushing rule with \" + category + \" -> \" + sString + ' ');\r\n                            var oRule = {\r\n                                category: category,\r\n                                matchedString: sString,\r\n                                type: IMatch.EnumRuleType.WORD,\r\n                                word: sString,\r\n                                bitindex: bitindex,\r\n                                bitSentenceAnd: bitindex,\r\n                                exactOnly: categoryRec.exactmatch || false,\r\n                                wordType: IMatch.WORDTYPE.FACT,\r\n                                _ranking: 0.95\r\n                            } as IMatch.mRule;\r\n                            insertRuleIfNotPresent(oModel.mRules, oRule, oModel.seenRules);\r\n                            //    if (oMdlData.synonyms && oMdlData.synonyms[category]) {\r\n                            //        throw new Error(\"how can this happen?\");\r\n                            //addSynonyms(oMdlData.synonyms[category], category, sString, bitindex, bitindex, \"X\", oModel.mRules, oModel.seenRules);\r\n                            //    }\r\n                            // a synonym for a FACT\r\n                            //    if (oEntry.synonyms && oEntry.synonyms[category]) {\r\n                            //         addSynonyms(oEntry.synonyms[category], category, sString, bitindex, bitindex, IMatch.WORDTYPE.FACT, oModel.mRules, oModel.seenRules);\r\n                            //     }\r\n                        });\r\n                        return true;\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    )\r\n    ).then(\r\n        () =>  getFactSynonyms(modelHandle, sModelName)\r\n    ).then((synonymValues : any) => {\r\n        synonymValues.forEach((synonymRec) => {\r\n        if (!hasRuleWithFact(oModel.mRules, synonymRec.fact, synonymRec.category, bitindex)) {\r\n            debuglog(() =>JSON.stringify(oModel.mRules,undefined,2));\r\n            throw Error(`Orphaned synonym without base in data?\\n`\r\n                                +\r\n                                `(check typos and that category is wordindexed!) fact: '${synonymRec.fact}';  category: \"${synonymRec.category}\"   `  + JSON.stringify(synonymRec))\r\n        }\r\n        addSynonyms(synonymRec.synonyms, synonymRec.category, synonymRec.fact, bitindex, bitindex, IMatch.WORDTYPE.FACT,\r\n                                oModel.mRules, oModel.seenRules);\r\n                            return true;\r\n                        });\r\n        return true;\r\n    });\r\n};\r\n\r\n\r\nfunction loadModelP(mongooseHndl ? : mongoose.Mongoose, connectionString? : string) : Promise<IMatch.IModels> {\r\n    var mongooseX = mongooseHndl || mongoose;\r\n    var connStr = connectionString || 'mongodb://localhost/testdb';\r\n    return MongoUtils.openMongoose(mongooseX, connStr).then(\r\n        () => getMongoHandle(mongooseX)\r\n    ).then( (modelHandle : IMatch.IModelHandleRaw) => loadModelsFull(modelHandle)\r\n    );\r\n};\r\n\r\n\r\n\r\n\r\n\r\nexport function loadModel(modelHandle: IMatch.IModelHandleRaw, sModelName: string, oModel: IMatch.IModels): Promise<any> {\r\n    debuglog(\" loading \" + sModelName + \" ....\");\r\n    //var oMdl = readFileAsJSON('./' + modelPath + '/' + sModelName + \".model.json\") as IModel;\r\n    var oMdl = makeMdlMongo(modelHandle, sModelName, oModel);\r\n    return loadModelDataMongo(modelHandle, oMdl, sModelName, oModel);\r\n}\r\n\r\n\r\nexport function getAllDomainsBitIndex(oModel: IMatch.IModels): number {\r\n    var len = oModel.domains.length;\r\n    var res = 0;\r\n    for (var i = 0; i < len; ++i) {\r\n        res = res << 1;\r\n        res = res | 0x0001;\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function getDomainBitIndex(domain: string, oModel: IMatch.IModels): number {\r\n    var index = oModel.domains.indexOf(domain);\r\n    if (index < 0) {\r\n        index = oModel.domains.length;\r\n    }\r\n    if (index >= 32) {\r\n        throw new Error(\"too many domain for single 32 bit index\");\r\n    }\r\n    return 0x0001 << index;\r\n}\r\n\r\n/**\r\n * Given a bitfield, return an unsorted set of domains matching present bits\r\n * @param oModel\r\n * @param bitfield\r\n */\r\nexport function getDomainsForBitField(oModel: IMatch.IModels, bitfield: number): string[] {\r\n    return oModel.domains.filter(domain =>\r\n        (getDomainBitIndex(domain, oModel) & bitfield)\r\n    );\r\n}\r\n\r\n/*\r\nfunction mergeModelJson(sModelName: string, oMdl: IModel, oModel: IMatch.IModels) {\r\n    var categoryDescribedMap = {} as { [key: string]: IMatch.ICategoryDesc };\r\n    oMdl.bitindex = getDomainBitIndex(oMdl.domain, oModel);\r\n    oMdl.categoryDescribed = [];\r\n    // rectify category\r\n    oMdl.category = oMdl.category.map(function (cat: any) {\r\n        if (typeof cat === \"string\") {\r\n            return cat;\r\n        }\r\n        if (typeof cat.name !== \"string\") {\r\n            console.log(\"Missing name in object typed category in \" + JSON.stringify(cat) + \" in model \" + sModelName);\r\n            process.exit(-1);\r\n            //throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n        }\r\n        categoryDescribedMap[cat.name] = cat;\r\n        oMdl.categoryDescribed.push(cat);\r\n        return cat.name;\r\n    });\r\n\r\n    // add the categories to the model:\r\n    oMdl.category.forEach(function (category) {\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"category\",\r\n            matchedString: category,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: category,\r\n            lowercaseword: category.toLowerCase(),\r\n            bitindex: oMdl.bitindex,\r\n            wordType : IMatch.WORDTYPE.CATEGORY,\r\n            bitSentenceAnd : oMdl.bitindex,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n    });\r\n\r\n    if (oModel.domains.indexOf(oMdl.domain) >= 0) {\r\n        debuglog(\"***********here mdl\" + JSON.stringify(oMdl, undefined, 2));\r\n        throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n    }\r\n    // check properties of model\r\n    Object.keys(oMdl).sort().forEach(function (sProperty) {\r\n        if (ARR_MODEL_PROPERTIES.indexOf(sProperty) < 0) {\r\n            throw new Error('Model property \"' + sProperty + '\" not a known model property in model of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    // consider streamlining the categories\r\n    oModel.rawModels[oMdl.domain] = oMdl;\r\n\r\n    oModel.full.domain[oMdl.domain] = {\r\n        description: oMdl.description,\r\n        categories: categoryDescribedMap,\r\n        bitindex: oMdl.bitindex\r\n    };\r\n\r\n    // check that\r\n\r\n\r\n    // check that members of wordindex are in categories,\r\n    oMdl.wordindex = oMdl.wordindex || [];\r\n    oMdl.wordindex.forEach(function (sWordIndex) {\r\n        if (oMdl.category.indexOf(sWordIndex) < 0) {\r\n            throw new Error('Model wordindex \"' + sWordIndex + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    oMdl.exactmatch = oMdl.exactmatch || [];\r\n    oMdl.exactmatch.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model exactmatch \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    oMdl.columns = oMdl.columns || [];\r\n    oMdl.columns.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model column \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n\r\n\r\n    // add relation domain -> category\r\n    var domainStr = MetaF.Domain(oMdl.domain).toFullString();\r\n    var relationStr = MetaF.Relation(Meta.RELATION_hasCategory).toFullString();\r\n    var reverseRelationStr = MetaF.Relation(Meta.RELATION_isCategoryOf).toFullString();\r\n    oMdl.category.forEach(function (sCategory) {\r\n\r\n        var CategoryString = MetaF.Category(sCategory).toFullString();\r\n        oModel.meta.t3[domainStr] = oModel.meta.t3[domainStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr] = oModel.meta.t3[domainStr][relationStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr][CategoryString] = {};\r\n\r\n        oModel.meta.t3[CategoryString] = oModel.meta.t3[CategoryString] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr] = oModel.meta.t3[CategoryString][reverseRelationStr] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr][domainStr] = {};\r\n\r\n    });\r\n\r\n    // add a precice domain matchrule\r\n    insertRuleIfNotPresent(oModel.mRules, {\r\n        category: \"domain\",\r\n        matchedString: oMdl.domain,\r\n        type: IMatch.EnumRuleType.WORD,\r\n        word: oMdl.domain,\r\n        bitindex: oMdl.bitindex,\r\n        bitSentenceAnd : oMdl.bitindex,\r\n        wordType : \"D\",\r\n        _ranking: 0.95\r\n    }, oModel.seenRules);\r\n\r\n    // check the tool\r\n    if (oMdl.tool && oMdl.tool.requires) {\r\n        var requires = Object.keys(oMdl.tool.requires || {});\r\n        var diff = _.difference(requires, oMdl.category);\r\n        if (diff.length > 0) {\r\n            console.log(` ${oMdl.domain} : Unkown category in requires of tool: \"` + diff.join('\"') + '\"');\r\n            process.exit(-1);\r\n        }\r\n        var optional = Object.keys(oMdl.tool.optional);\r\n        diff = _.difference(optional, oMdl.category);\r\n        if (diff.length > 0) {\r\n            console.log(` ${oMdl.domain} : Unkown category optional of tool: \"` + diff.join('\"') + '\"');\r\n            process.exit(-1);\r\n        }\r\n        Object.keys(oMdl.tool.sets || {}).forEach(function (setID) {\r\n            var diff = _.difference(oMdl.tool.sets[setID].set, oMdl.category);\r\n            if (diff.length > 0) {\r\n                console.log(` ${oMdl.domain} : Unkown category in setId ${setID} of tool: \"` + diff.join('\"') + '\"');\r\n                process.exit(-1);\r\n            }\r\n        });\r\n\r\n        // extract tools an add to tools:\r\n        oModel.tools.filter(function (oEntry) {\r\n            if (oEntry.name === (oMdl.tool && oMdl.tool.name)) {\r\n                console.log(\"Tool \" + oMdl.tool.name + \" already present when loading \" + sModelName);\r\n                //throw new Error('Domain already loaded?');\r\n                process.exit(-1);\r\n            }\r\n        });\r\n    } else {\r\n        oMdl.toolhidden = true;\r\n        oMdl.tool.requires = { \"impossible\": {} };\r\n    }\r\n    // add the tool name as rule unless hidden\r\n    if (!oMdl.toolhidden && oMdl.tool && oMdl.tool.name) {\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"tool\",\r\n            matchedString: oMdl.tool.name,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: oMdl.tool.name,\r\n            bitindex: oMdl.bitindex,\r\n            bitSentenceAnd : oMdl.bitindex,\r\n            wordType : IMatch.WORDTYPE.TOOL,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n    };\r\n    if (oMdl.synonyms && oMdl.synonyms[\"tool\"]) {\r\n        addSynonyms(oMdl.synonyms[\"tool\"], \"tool\", oMdl.tool.name, oMdl.bitindex,\r\n        oMdl.bitindex, IMatch.WORDTYPE.TOOL, oModel.mRules, oModel.seenRules);\r\n    };\r\n    if (oMdl.synonyms) {\r\n        Object.keys(oMdl.synonyms).forEach(function (ssynkey) {\r\n            if (oMdl.category.indexOf(ssynkey) >= 0 && ssynkey !== \"tool\") {\r\n                if (oModel.full.domain[oMdl.domain].categories[ssynkey]) {\r\n                    oModel.full.domain[oMdl.domain].categories[ssynkey].category_synonyms = oMdl.synonyms[ssynkey];\r\n                }\r\n                addSynonyms(oMdl.synonyms[ssynkey], \"category\", ssynkey, oMdl.bitindex, oMdl.bitindex,\r\n                IMatch.WORDTYPE.CATEGORY, oModel.mRules, oModel.seenRules);\r\n            }\r\n        });\r\n    }\r\n    oModel.domains.push(oMdl.domain);\r\n    if (oMdl.tool.name) {\r\n        oModel.tools.push(oMdl.tool);\r\n    }\r\n    oModel.category = oModel.category.concat(oMdl.category);\r\n    oModel.category.sort();\r\n    oModel.category = oModel.category.filter(function (string, index) {\r\n        return oModel.category[index] !== oModel.category[index + 1];\r\n    });\r\n\r\n} // loadmodel\r\n*/\r\n\r\nfunction makeMdlMongo(modelHandle: IMatch.IModelHandleRaw, sModelName: string, oModel: IMatch.IModels): IModel {\r\n    var modelDoc = modelHandle.modelDocs[sModelName];\r\n    var oMdl = {\r\n        bitindex: getDomainBitIndex(modelDoc.domain, oModel),\r\n        domain: modelDoc.domain,\r\n        modelname: sModelName,\r\n        description: modelDoc.domain_description\r\n    } as IModel;\r\n    var categoryDescribedMap = {} as { [key: string]: IMatch.ICategoryDesc };\r\n\r\n    oMdl.bitindex = getDomainBitIndex(modelDoc.domain, oModel);\r\n    oMdl.category = modelDoc._categories.map(cat => cat.category);\r\n    oMdl.categoryDescribed = [];\r\n    modelDoc._categories.forEach(cat => {\r\n        oMdl.categoryDescribed.push({\r\n            name: cat.category,\r\n            description: cat.category_description\r\n        })\r\n        categoryDescribedMap[cat.category] = cat;\r\n    });\r\n\r\n    oMdl.category = modelDoc._categories.map(cat => cat.category);\r\n\r\n    /* // rectify category\r\n     oMdl.category = oMdl.category.map(function (cat: any) {\r\n         if (typeof cat === \"string\") {\r\n             return cat;\r\n         }\r\n         if (typeof cat.name !== \"string\") {\r\n             console.log(\"Missing name in object typed category in \" + JSON.stringify(cat) + \" in model \" + sModelName);\r\n             process.exit(-1);\r\n             //throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n         }\r\n         categoryDescribedMap[cat.name] = cat;\r\n         oMdl.categoryDescribed.push(cat);\r\n         return cat.name;\r\n     });\r\n     */\r\n\r\n    // add the categories to the rules\r\n    oMdl.category.forEach(function (category) {\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"category\",\r\n            matchedString: category,\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: category,\r\n            lowercaseword: category.toLowerCase(),\r\n            bitindex: oMdl.bitindex,\r\n            wordType: IMatch.WORDTYPE.CATEGORY,\r\n            bitSentenceAnd: oMdl.bitindex,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n    });\r\n\r\n    // add synonanym for the categories to the\r\n\r\n    modelDoc._categories.forEach(cat => {\r\n        addSynonyms\r\n\r\n    });\r\n\r\n    if (oModel.domains.indexOf(oMdl.domain) >= 0) {\r\n        debuglog(\"***********here mdl\" + JSON.stringify(oMdl, undefined, 2));\r\n        throw new Error('Domain ' + oMdl.domain + ' already loaded while loading ' + sModelName + '?');\r\n    }\r\n    /*\r\n    // check properties of model\r\n    Object.keys(oMdl).sort().forEach(function (sProperty) {\r\n        if (ARR_MODEL_PROPERTIES.indexOf(sProperty) < 0) {\r\n            throw new Error('Model property \"' + sProperty + '\" not a known model property in model of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    */\r\n\r\n    // consider streamlining the categories\r\n    oModel.rawModels[oMdl.domain] = oMdl;\r\n\r\n    oModel.full.domain[oMdl.domain] = {\r\n        description: oMdl.description,\r\n        categories: categoryDescribedMap,\r\n        bitindex: oMdl.bitindex\r\n    };\r\n\r\n    // check that\r\n\r\n\r\n    // check that members of wordindex are in categories,\r\n    /* oMdl.wordindex = oModelDoc.oMdl.wordindex || [];\r\n     oMdl.wordindex.forEach(function (sWordIndex) {\r\n         if (oMdl.category.indexOf(sWordIndex) < 0) {\r\n             throw new Error('Model wordindex \"' + sWordIndex + '\" not a category of domain ' + oMdl.domain + ' ');\r\n         }\r\n     });\r\n     */\r\n    /*\r\n    oMdl.exactmatch = oMdl.exactmatch || [];\r\n    oMdl.exactmatch.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model exactmatch \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n    */\r\n    oMdl.columns = modelDoc.columns; // oMdl.columns || [];\r\n    oMdl.columns.forEach(function (sExactMatch) {\r\n        if (oMdl.category.indexOf(sExactMatch) < 0) {\r\n            throw new Error('Model column \"' + sExactMatch + '\" not a category of domain ' + oMdl.domain + ' ');\r\n        }\r\n    });\r\n\r\n\r\n    // add relation domain -> category\r\n    var domainStr = MetaF.Domain(oMdl.domain).toFullString();\r\n    var relationStr = MetaF.Relation(Meta.RELATION_hasCategory).toFullString();\r\n    var reverseRelationStr = MetaF.Relation(Meta.RELATION_isCategoryOf).toFullString();\r\n    oMdl.category.forEach(function (sCategory) {\r\n\r\n        var CategoryString = MetaF.Category(sCategory).toFullString();\r\n        oModel.meta.t3[domainStr] = oModel.meta.t3[domainStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr] = oModel.meta.t3[domainStr][relationStr] || {};\r\n        oModel.meta.t3[domainStr][relationStr][CategoryString] = {};\r\n\r\n        oModel.meta.t3[CategoryString] = oModel.meta.t3[CategoryString] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr] = oModel.meta.t3[CategoryString][reverseRelationStr] || {};\r\n        oModel.meta.t3[CategoryString][reverseRelationStr][domainStr] = {};\r\n\r\n    });\r\n\r\n    // add a precice domain matchrule\r\n    insertRuleIfNotPresent(oModel.mRules, {\r\n        category: \"domain\",\r\n        matchedString: oMdl.domain,\r\n        type: IMatch.EnumRuleType.WORD,\r\n        word: oMdl.domain,\r\n        bitindex: oMdl.bitindex,\r\n        bitSentenceAnd: oMdl.bitindex,\r\n        wordType: IMatch.WORDTYPE.DOMAIN,\r\n        _ranking: 0.95\r\n    }, oModel.seenRules);\r\n\r\n    // add domain synonyms\r\n    if (modelDoc.domain_synonyms && modelDoc.domain_synonyms.length > 0) {\r\n        addSynonyms(modelDoc.domain_synonyms, \"domain\", modelDoc.domain, oMdl.bitindex,\r\n            oMdl.bitindex, IMatch.WORDTYPE.DOMAIN, oModel.mRules, oModel.seenRules);\r\n    };\r\n\r\n\r\n    /*\r\n        // check the tool\r\n        if (oMdl.tool && oMdl.tool.requires) {\r\n            var requires = Object.keys(oMdl.tool.requires || {});\r\n            var diff = _.difference(requires, oMdl.category);\r\n            if (diff.length > 0) {\r\n                console.log(` ${oMdl.domain} : Unkown category in requires of tool: \"` + diff.join('\"') + '\"');\r\n                process.exit(-1);\r\n            }\r\n            var optional = Object.keys(oMdl.tool.optional);\r\n            diff = _.difference(optional, oMdl.category);\r\n            if (diff.length > 0) {\r\n                console.log(` ${oMdl.domain} : Unkown category optional of tool: \"` + diff.join('\"') + '\"');\r\n                process.exit(-1);\r\n            }\r\n            Object.keys(oMdl.tool.sets || {}).forEach(function (setID) {\r\n                var diff = _.difference(oMdl.tool.sets[setID].set, oMdl.category);\r\n                if (diff.length > 0) {\r\n                    console.log(` ${oMdl.domain} : Unkown category in setId ${setID} of tool: \"` + diff.join('\"') + '\"');\r\n                    process.exit(-1);\r\n                }\r\n            });\r\n\r\n            // extract tools an add to tools:\r\n            oModel.tools.filter(function (oEntry) {\r\n                if (oEntry.name === (oMdl.tool && oMdl.tool.name)) {\r\n                    console.log(\"Tool \" + oMdl.tool.name + \" already present when loading \" + sModelName);\r\n                    //throw new Error('Domain already loaded?');\r\n                    process.exit(-1);\r\n                }\r\n            });\r\n        } else {\r\n            oMdl.toolhidden = true;\r\n            oMdl.tool.requires = { \"impossible\": {} };\r\n        }\r\n        // add the tool name as rule unless hidden\r\n        if (!oMdl.toolhidden && oMdl.tool && oMdl.tool.name) {\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"tool\",\r\n                matchedString: oMdl.tool.name,\r\n                type: IMatch.EnumRuleType.WORD,\r\n                word: oMdl.tool.name,\r\n                bitindex: oMdl.bitindex,\r\n                bitSentenceAnd : oMdl.bitindex,\r\n                wordType : IMatch.WORDTYPE.TOOL,\r\n                _ranking: 0.95\r\n            }, oModel.seenRules);\r\n        };\r\n        if (oMdl.synonyms && oMdl.synonyms[\"tool\"]) {\r\n            addSynonyms(oMdl.synonyms[\"tool\"], \"tool\", oMdl.tool.name, oMdl.bitindex,\r\n            oMdl.bitindex, IMatch.WORDTYPE.TOOL, oModel.mRules, oModel.seenRules);\r\n        };\r\n        */\r\n\r\n    // add synsonym for the domains\r\n\r\n\r\n    // add synonyms for the categories\r\n\r\n    modelDoc._categories.forEach(cat => {\r\n        if (cat.category_synonyms && cat.category_synonyms.length > 0) {\r\n            if (oModel.full.domain[oMdl.domain].categories[cat.category]) {\r\n                oModel.full.domain[oMdl.domain].categories[cat.category].category_synonyms = cat.category_synonyms;\r\n            }\r\n            addSynonyms(cat.category_synonyms, \"category\", cat.category, oMdl.bitindex, oMdl.bitindex,\r\n                IMatch.WORDTYPE.CATEGORY, oModel.mRules, oModel.seenRules);\r\n        }\r\n    }\r\n    );\r\n\r\n    // add operators\r\n\r\n\r\n    // add fillers\r\n\r\n    oModel.domains.push(oMdl.domain);\r\n    oModel.category = oModel.category.concat(oMdl.category);\r\n    oModel.category.sort();\r\n    oModel.category = oModel.category.filter(function (string, index) {\r\n        return oModel.category[index] !== oModel.category[index + 1];\r\n    });\r\n    return oMdl;\r\n} // loadmodel\r\n\r\n\r\n\r\nexport function splitRules(rules: IMatch.mRule[]): IMatch.SplitRules {\r\n    var res = {};\r\n    var nonWordRules = [];\r\n    rules.forEach(function (rule) {\r\n        if (rule.type === IMatch.EnumRuleType.WORD) {\r\n            if (!rule.lowercaseword) {\r\n                throw new Error(\"Rule has no member lowercaseword\" + JSON.stringify(rule));\r\n            }\r\n            res[rule.lowercaseword] = res[rule.lowercaseword] || { bitindex: 0, rules: [] };\r\n            res[rule.lowercaseword].bitindex = res[rule.lowercaseword].bitindex | rule.bitindex;\r\n            res[rule.lowercaseword].rules.push(rule);\r\n        } else {\r\n            nonWordRules.push(rule);\r\n        }\r\n    });\r\n    return {\r\n        wordMap: res,\r\n        nonWordRules: nonWordRules,\r\n        allRules: rules,\r\n        wordCache: {}\r\n    };\r\n}\r\n\r\nfunction cmpLengthSort(a: string, b: string) {\r\n    var d = a.length - b.length;\r\n    if (d) {\r\n        return d;\r\n    }\r\n    return a.localeCompare(b);\r\n}\r\n\r\n\r\nimport * as Algol from '../match/algol';\r\n// offset[0] : len-2\r\n//             len -1\r\n//             len\r\n//             len +1\r\n//             len +2\r\n//             len +3\r\n\r\nexport function findNextLen(targetLen: number, arr: string[], offsets: number[]) {\r\n    offsets.shift();\r\n    for (var i = offsets[4]; (i < arr.length) && (arr[i].length <= targetLen); ++i) {\r\n        /* empty*/\r\n    }\r\n    //console.log(\"pushing \" + i);\r\n    offsets.push(i);\r\n}\r\n\r\nexport function addRangeRulesUnlessPresent(rules: IMatch.mRule[], lcword: string, rangeRules: IMatch.mRule[], presentRulesForKey: IMatch.mRule[], seenRules) {\r\n    rangeRules.forEach(rangeRule => {\r\n        var newRule = (Object as any).assign({}, rangeRule);\r\n        newRule.lowercaseword = lcword;\r\n        newRule.word = lcword;\r\n        //if((lcword === 'services' || lcword === 'service') && newRule.range.rule.lowercaseword.indexOf('odata')>=0) {\r\n        //    console.log(\"adding \"+ JSON.stringify(newRule) + \"\\n\");\r\n        //}\r\n        //todo: check whether an equivalent rule is already present?\r\n        var cnt = rules.length;\r\n        insertRuleIfNotPresent(rules, newRule, seenRules);\r\n    })\r\n}\r\n\r\n\r\nexport function addCloseExactRangeRules(rules: IMatch.mRule[], seenRules) {\r\n    var keysMap = {} as { [key: string]: IMatch.mRule[] };\r\n    var rangeKeysMap = {} as { [key: string]: IMatch.mRule[] };\r\n    rules.forEach(rule => {\r\n        if (rule.type === IMatch.EnumRuleType.WORD) {\r\n            //keysMap[rule.lowercaseword] = 1;\r\n            keysMap[rule.lowercaseword] = keysMap[rule.lowercaseword] || [];\r\n            keysMap[rule.lowercaseword].push(rule);\r\n            if (!rule.exactOnly && rule.range) {\r\n                rangeKeysMap[rule.lowercaseword] = rangeKeysMap[rule.lowercaseword] || [];\r\n                rangeKeysMap[rule.lowercaseword].push(rule);\r\n            }\r\n        }\r\n    });\r\n    var keys = Object.keys(keysMap);\r\n    keys.sort(cmpLengthSort);\r\n    var len = 0;\r\n    keys.forEach((key, index) => {\r\n        if (key.length != len) {\r\n            //console.log(\"shift to len\" + key.length + ' at ' + index + ' ' + key );\r\n        }\r\n        len = key.length;\r\n    });\r\n    //   keys = keys.slice(0,2000);\r\n    var rangeKeys = Object.keys(rangeKeysMap);\r\n    rangeKeys.sort(cmpLengthSort);\r\n    //console.log(` ${keys.length} keys and ${rangeKeys.length} rangekeys `);\r\n    var low = 0;\r\n    var high = 0;\r\n    var lastlen = 0;\r\n    var offsets = [0, 0, 0, 0, 0, 0];\r\n    var len = rangeKeys.length;\r\n    findNextLen(0, keys, offsets);\r\n    findNextLen(1, keys, offsets);\r\n    findNextLen(2, keys, offsets);\r\n\r\n    rangeKeys.forEach(function (rangeKey) {\r\n        if (rangeKey.length !== lastlen) {\r\n            for (i = lastlen + 1; i <= rangeKey.length; ++i) {\r\n                findNextLen(i + 2, keys, offsets);\r\n            }\r\n            //   console.log(` shifted to ${rangeKey.length} with offsets beeing ${offsets.join(' ')}`);\r\n            //   console.log(` here 0 ${offsets[0]} : ${keys[Math.min(keys.length-1, offsets[0])].length}  ${keys[Math.min(keys.length-1, offsets[0])]} `);\r\n            //  console.log(` here 5-1  ${keys[offsets[5]-1].length}  ${keys[offsets[5]-1]} `);\r\n            //   console.log(` here 5 ${offsets[5]} : ${keys[Math.min(keys.length-1, offsets[5])].length}  ${keys[Math.min(keys.length-1, offsets[5])]} `);\r\n            lastlen = rangeKey.length;\r\n        }\r\n        for (var i = offsets[0]; i < offsets[5]; ++i) {\r\n            var d = Distance.calcDistanceAdjusted(rangeKey, keys[i]);\r\n            // console.log(`${rangeKey.length-keys[i].length} ${d} ${rangeKey} and ${keys[i]}  `);\r\n            if ((d !== 1.0) && (d >= Algol.Cutoff_rangeCloseMatch)) {\r\n                //console.log(`would add ${rangeKey} for ${keys[i]} ${d}`);\r\n                var cnt = rules.length;\r\n                // we only have to add if there is not yet a match rule here which points to the same\r\n                addRangeRulesUnlessPresent(rules, keys[i], rangeKeysMap[rangeKey], keysMap[keys[i]], seenRules);\r\n                if (rules.length > cnt) {\r\n                    //console.log(` added ${(rules.length - cnt)} records at${rangeKey} for ${keys[i]} ${d}`);\r\n                }\r\n\r\n            }\r\n        }\r\n    });\r\n    /*\r\n    [\r\n        ['aEFG','aEFGH'],\r\n        ['aEFGH','aEFGHI'],\r\n        ['Odata','ODatas'],\r\n   ['Odata','Odatas'],\r\n   ['Odata','Odatb'],\r\n   ['Odata','UData'],\r\n   ['service','services'],\r\n   ['this isfunny and more','this isfunny and mores'],\r\n    ].forEach(rec => {\r\n        console.log(`distance ${rec[0]} ${rec[1]} : ${Distance.calcDistance(rec[0],rec[1])}  adf ${Distance.calcDistanceAdjusted(rec[0],rec[1])} `);\r\n\r\n    });\r\n    console.log(\"distance Odata Udata\"+ Distance.calcDistance('OData','UData'));\r\n    console.log(\"distance Odata Odatb\"+ Distance.calcDistance('OData','ODatb'));\r\n    console.log(\"distance Odatas Odata\"+ Distance.calcDistance('OData','ODataa'));\r\n    console.log(\"distance Odatas abcde\"+ Distance.calcDistance('abcde','abcdef'));\r\n    console.log(\"distance services \"+ Distance.calcDistance('services','service'));\r\n    */\r\n}\r\nvar n = 0;\r\n\r\n\r\nexport function readFillers(mongoose : mongoose.Mongoose, oModel : IMatch.IModels)  : Promise<any> {\r\n    var fillerBitIndex = getDomainBitIndex('meta', oModel);\r\n    var bitIndexAllDomains = getAllDomainsBitIndex(oModel);\r\n    return Schemaload.getFillersFromDB(mongoose).then(\r\n        (fillersObj) => fillersObj.fillers\r\n    ).then((fillers: string[]) => {\r\n        //  fillersreadFileAsJSON('./' + modelPath + '/filler.json');\r\n        /*\r\n        var re = \"^((\" + fillers.join(\")|(\") + \"))$\";\r\n        oModel.mRules.push({\r\n            category: \"filler\",\r\n            type: IMatch.EnumRuleType.REGEXP,\r\n            regexp: new RegExp(re, \"i\"),\r\n            matchedString: \"filler\",\r\n            bitindex: fillerBitIndex,\r\n            _ranking: 0.9\r\n        });\r\n        */\r\n        if (!_.isArray(fillers)) {\r\n            throw new Error('expect fillers to be an array of strings');\r\n        }\r\n        fillers.forEach(filler => {\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"filler\",\r\n                type: IMatch.EnumRuleType.WORD,\r\n                word: filler,\r\n                lowercaseword: filler.toLowerCase(),\r\n                matchedString: filler, //\"filler\",\r\n                exactOnly: true,\r\n                bitindex: fillerBitIndex,\r\n                bitSentenceAnd: bitIndexAllDomains,\r\n                wordType: IMatch.WORDTYPE.FILLER,\r\n                _ranking: 0.9\r\n            }, oModel.seenRules);\r\n        });\r\n        return true;\r\n    });\r\n};\r\n\r\n\r\nexport function readOperators(mongoose: mongoose.Mongoose, oModel: IMatch.IModels) : Promise<any> {\r\n        debuglog('reading operators');\r\n        //add operators\r\n    return Schemaload.getOperatorsFromDB(mongoose).then(\r\n        (operators: any) => {\r\n        var operatorBitIndex = getDomainBitIndex('operators', oModel);\r\n        var bitIndexAllDomains = getAllDomainsBitIndex(oModel);\r\n        Object.keys(operators.operators).forEach(function (operator) {\r\n            if (IMatch.aOperatorNames.indexOf(operator) < 0) {\r\n                debuglog(\"unknown operator \" + operator);\r\n                throw new Error(\"unknown operator \" + operator);\r\n            }\r\n            oModel.operators[operator] = operators.operators[operator];\r\n            oModel.operators[operator].operator = <IMatch.OperatorName>operator;\r\n            Object.freeze(oModel.operators[operator]);\r\n            var word = operator;\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"operator\",\r\n                word: word.toLowerCase(),\r\n                lowercaseword: word.toLowerCase(),\r\n                type: IMatch.EnumRuleType.WORD,\r\n                matchedString: word,\r\n                bitindex: operatorBitIndex,\r\n                bitSentenceAnd: bitIndexAllDomains,\r\n                wordType: IMatch.WORDTYPE.OPERATOR,\r\n                _ranking: 0.9\r\n            }, oModel.seenRules);\r\n            // add all synonyms\r\n            if (operators.synonyms[operator]) {\r\n                Object.keys(operators.synonyms[operator]).forEach(function (synonym) {\r\n                    insertRuleIfNotPresent(oModel.mRules, {\r\n                        category: \"operator\",\r\n                        word: synonym.toLowerCase(),\r\n                        lowercaseword: synonym.toLowerCase(),\r\n                        type: IMatch.EnumRuleType.WORD,\r\n                        matchedString: operator,\r\n                        bitindex: operatorBitIndex,\r\n                        bitSentenceAnd: bitIndexAllDomains,\r\n                        wordType: IMatch.WORDTYPE.OPERATOR,\r\n                        _ranking: 0.9\r\n                    }, oModel.seenRules);\r\n                });\r\n            }\r\n            return true;\r\n        });\r\n        return true;\r\n    });\r\n};\r\n\r\nexport function releaseModel(model : IMatch.IModels) {\r\n    if(model.mongoHandle && model.mongoHandle.mongoose) {\r\n        MongoUtils.disconnect(model.mongoHandle.mongoose);\r\n    }\r\n}\r\n\r\nexport function loadModelHandleP(mongooseHndl ? : mongoose.Mongoose, connectionString? : string) : Promise<IMatch.IModels> {\r\n    var mongooseX = mongooseHndl || mongoose;\r\n //   if(process.env.MONGO_REPLAY) {\r\n //        mongooseX = mongooseMock.mongooseMock as any;\r\n //    }\r\n    var connStr = connectionString || 'mongodb://localhost/testdb';\r\n    return MongoUtils.openMongoose(mongooseX, connStr).then(\r\n        () => getMongoHandle(mongooseX)\r\n    ).then( (modelHandle : IMatch.IModelHandleRaw) => loadModelsFull(modelHandle));\r\n};\r\n\r\n\r\nexport function loadModelsOpeningConnection(mongooseHndl: mongoose.Mongoose, connectionString? : string,  modelPath? : string) : Promise<IMatch.IModels> {\r\n  var mongooseX = mongooseHndl || mongoose;\r\n //   if(process.env.MONGO_REPLAY) {\r\n //        mongooseX = mongooseMock.mongooseMock as any;\r\n //    }\r\n    var connStr = connectionString || 'mongodb://localhost/testdb';\r\n    return MongoUtils.openMongoose(mongooseX, connStr).then(\r\n        ()=>\r\n            {\r\n            return loadModels(mongooseX, modelPath);\r\n            }\r\n    );\r\n}\r\n\r\n/**\r\n * expects an open connection!\r\n * @param mongoose\r\n * @param modelPath\r\n */\r\nexport function loadModels(mongoose: mongoose.Mongoose, modelPath? : string) : Promise<IMatch.IModels> {\r\n    return getMongoHandle(mongoose).then( (modelHandle) =>{\r\n        debuglog('got a mongo handle');\r\n        return loadModelsFull(modelHandle, modelPath);\r\n    });\r\n}\r\n\r\nexport function loadModelsFull(modelHandle: IMatch.IModelHandleRaw, modelPath?: string): Promise<IMatch.IModels> {\r\n    var oModel: IMatch.IModels;\r\n    modelPath = modelPath || envModelPath;\r\n    modelHandle = modelHandle || {\r\n        mongoose: undefined,\r\n        modelDocs: {},\r\n        mongoMaps: {},\r\n        modelESchemas: {}\r\n    };\r\n    oModel = {\r\n        mongoHandle : modelHandle,\r\n        full: { domain: {} },\r\n        rawModels: {},\r\n        domains: [],\r\n        rules: undefined,\r\n        category: [],\r\n        operators: {},\r\n        mRules: [],\r\n        seenRules: {},\r\n        meta: { t3: {} }\r\n    }\r\n    var t = Date.now();\r\n\r\n    try {\r\n        var a = CircularSer.load('./' + modelPath + '/_cachefalse.js');\r\n      // TODO\r\n        a = undefined;\r\n        //console.log(\"found a cache ?  \" + !!a);\r\n        //a = undefined;\r\n        if (a) {\r\n            //console.log('return preps' + modelPath);\r\n            debuglog(\" return prepared model \");\r\n            if (process.env.ABOT_EMAIL_USER) {\r\n                console.log(\"loaded models from cache in \" + (Date.now() - t) + \" \");\r\n            }\r\n            var res = (Object as any).assign(modelHandle, { model: a });\r\n            return Promise.resolve(res);\r\n        }\r\n    } catch (e) {\r\n        //console.log('error' + e);\r\n        // no cache file,\r\n    }\r\n    //var mdls = readFileAsJSON('./' + modelPath + '/models.json');\r\n\r\n    var mdls = Object.keys(modelHandle.modelDocs).sort();\r\n\r\n    // create bitindex in order !\r\n    debuglog('loading models ' + mdls.join(\"\\n\"));\r\n    return Promise.all(mdls.map((sModelName) =>\r\n        loadModel(modelHandle, sModelName, oModel))\r\n    ).then(() => {\r\n\r\n\r\n        // add the categories to the model:\r\n        /*\r\n        oModel.category.forEach(function (category) {\r\n            insertRuleIfNotPresent(oModel.mRules, {\r\n                category: \"category\",\r\n                matchedString: category,\r\n                type: IMatch.EnumRuleType.WORD,\r\n                word: category,\r\n                lowercaseword: category.toLowerCase(),\r\n                bitindex : oMdl.\r\n                _ranking: 0.95\r\n            }, oModel.seenRules);\r\n        });\r\n        */\r\n\r\n        var metaBitIndex = getDomainBitIndex('meta', oModel);\r\n        var bitIndexAllDomains = getAllDomainsBitIndex(oModel);\r\n\r\n        // add the domain meta rule\r\n        insertRuleIfNotPresent(oModel.mRules, {\r\n            category: \"meta\",\r\n            matchedString: \"domain\",\r\n            type: IMatch.EnumRuleType.WORD,\r\n            word: \"domain\",\r\n            bitindex: metaBitIndex,\r\n            wordType: IMatch.WORDTYPE.META,\r\n            bitSentenceAnd: bitIndexAllDomains,\r\n            _ranking: 0.95\r\n        }, oModel.seenRules);\r\n        return true;\r\n    }\r\n    ).then( ()=>\r\n        readFillers(modelHandle.mongoose, oModel)\r\n    ).then( () =>\r\n        readOperators(modelHandle.mongoose, oModel)\r\n    ).then( () => {\r\n        /*\r\n            })\r\n                {\r\n              category: \"filler\",\r\n              type: 1,\r\n              regexp: /^((start)|(show)|(from)|(in))$/i,\r\n              matchedString: \"filler\",\r\n              _ranking: 0.9\r\n            },\r\n        */\r\n        debuglog('saving data to ' + modelPath);\r\n        oModel.mRules = oModel.mRules.sort(InputFilterRules.cmpMRule);\r\n        addCloseExactRangeRules(oModel.mRules, oModel.seenRules);\r\n        oModel.mRules = oModel.mRules.sort(InputFilterRules.cmpMRule);\r\n        oModel.mRules.sort(InputFilterRules.cmpMRule);\r\n        fs.writeFileSync(\"post_sort\", JSON.stringify(oModel.mRules,undefined,2));\r\n\r\n        forceGC();\r\n        oModel.rules = splitRules(oModel.mRules);\r\n        fs.writeFileSync(\"test1x.json\", JSON.stringify(oModel.rules,undefined,2));\r\n        forceGC();\r\n        delete oModel.seenRules;\r\n        debuglog('saving');\r\n        forceGC();\r\n        CircularSer.save('./' + modelPath + '/_cachefalse.js', oModel);\r\n        forceGC();\r\n        if (process.env.ABOT_EMAIL_USER) {\r\n            console.log(\"loaded models by calculation in \" + (Date.now() - t) + \" \");\r\n        }\r\n\r\n        var res = oModel;\r\n        // (Object as any).assign(modelHandle, { model: oModel }) as IMatch.IModelHandle;\r\n\r\n        return res;\r\n    }\r\n    ).catch( (err) => {\r\n        console.log(err + ' ' + err.stack);\r\n        process.exit(-1);\r\n    })\r\n}\r\n\r\nexport function sortCategoriesByImportance(map: { [key: string]: IMatch.ICategoryDesc }, cats: string[]): string[] {\r\n    var res = cats.slice(0);\r\n    res.sort(rankCategoryByImportance.bind(undefined, map));\r\n    return res;\r\n}\r\n\r\nexport function rankCategoryByImportance(map: { [key: string]: IMatch.ICategoryDesc }, cata: string, catb: string): number {\r\n    var catADesc = map[cata];\r\n    var catBDesc = map[catb];\r\n    if (cata === catb) {\r\n        return 0;\r\n    }\r\n    // if a is before b, return -1\r\n    if (catADesc && !catBDesc) {\r\n        return -1;\r\n    }\r\n    if (!catADesc && catBDesc) {\r\n        return +1;\r\n    }\r\n\r\n    var prioA = (catADesc && catADesc.importance) || 99;\r\n    var prioB = (catBDesc && catBDesc.importance) || 99;\r\n    // lower prio goes to front\r\n    var r = prioA - prioB;\r\n    if (r) {\r\n        return r;\r\n    }\r\n    return cata.localeCompare(catb);\r\n}\r\n\r\nconst MetaF = Meta.getMetaFactory();\r\n\r\nexport function getOperator(mdl: IMatch.IModels, operator: string): IMatch.IOperator {\r\n    return mdl.operators[operator];\r\n}\r\n\r\nexport function getResultAsArray(mdl: IMatch.IModels, a: Meta.IMeta, rel: Meta.IMeta): Meta.IMeta[] {\r\n    if (rel.toType() !== 'relation') {\r\n        throw new Error(\"expect relation as 2nd arg\");\r\n    }\r\n\r\n    var res = mdl.meta.t3[a.toFullString()] &&\r\n        mdl.meta.t3[a.toFullString()][rel.toFullString()];\r\n    if (!res) {\r\n        return [];\r\n    }\r\n    return Object.getOwnPropertyNames(res).sort().map(MetaF.parseIMeta);\r\n}\r\n\r\nexport function getCategoriesForDomain(theModel: IMatch.IModels, domain: string): string[] {\r\n    if (theModel.domains.indexOf(domain) < 0) {\r\n        throw new Error(\"Domain \\\"\" + domain + \"\\\" not part of model\");\r\n    }\r\n    var res = getResultAsArray(theModel, MetaF.Domain(domain), MetaF.Relation(Meta.RELATION_hasCategory));\r\n    return Meta.getStringArray(res);\r\n}\r\n\r\nexport function getTableColumns(theModel: IMatch.IModels, domain: string): string[] {\r\n    if (theModel.domains.indexOf(domain) < 0) {\r\n        throw new Error(\"Domain \\\"\" + domain + \"\\\" not part of model\");\r\n    }\r\n    return theModel.rawModels[domain].columns.slice(0);\r\n}\r\n\r\nfunction forceGC() {\r\n    if (global && global.gc) {\r\n        global.gc();\r\n    }\r\n}\r\n\r\n/**\r\n * Return all categories of a domain which can appear on a word,\r\n * these are typically the wordindex domains + entries generated by generic rules\r\n *\r\n * The current implementation is a simplification\r\n */\r\nexport function getPotentialWordCategoriesForDomain(theModel: IMatch.IModels, domain: string): string[] {\r\n    // this is a simplified version\r\n    return getCategoriesForDomain(theModel, domain);\r\n}\r\n\r\nexport function getDomainsForCategory(theModel: IMatch.IModels, category: string): string[] {\r\n    if (theModel.category.indexOf(category) < 0) {\r\n        throw new Error(\"Category \\\"\" + category + \"\\\" not part of model\");\r\n    }\r\n    var res = getResultAsArray(theModel, MetaF.Category(category), MetaF.Relation(Meta.RELATION_isCategoryOf));\r\n    return Meta.getStringArray(res);\r\n}\r\n\r\n/*\r\nexport function getAllRecordCategoriesForTargetCategory(model: IMatch.IModels, category: string, wordsonly: boolean): { [key: string]: boolean } {\r\n    var res = {};\r\n    //\r\n    var fn = wordsonly ? getPotentialWordCategoriesForDomain : getCategoriesForDomain;\r\n    var domains = getDomainsForCategory(model, category);\r\n    domains.forEach(function (domain) {\r\n        fn(model, domain).forEach(function (wordcat) {\r\n            res[wordcat] = true;\r\n        });\r\n    });\r\n    Object.freeze(res);\r\n    return res;\r\n}\r\n\r\nexport function getAllRecordCategoriesForTargetCategories(model: IMatch.IModels, categories: string[], wordsonly: boolean): { [key: string]: boolean } {\r\n    var res = {};\r\n    //\r\n    var fn = wordsonly ? getPotentialWordCategoriesForDomain : getCategoriesForDomain;\r\n    var domains = undefined;\r\n    categories.forEach(function (category) {\r\n        var catdomains = getDomainsForCategory(model, category)\r\n        if (!domains) {\r\n            domains = catdomains;\r\n        } else {\r\n            domains = _.intersection(domains, catdomains);\r\n        }\r\n    });\r\n    if (domains.length === 0) {\r\n        throw new Error('categories ' + Utils.listToQuotedCommaAnd(categories) + ' have no common domain.')\r\n    }\r\n    domains.forEach(function (domain) {\r\n        fn(model, domain).forEach(function (wordcat) {\r\n            res[wordcat] = true;\r\n        });\r\n    });\r\n    Object.freeze(res);\r\n    return res;\r\n}\r\n*/\r\n\r\n/**\r\n * givena  set  of categories, return a structure\r\n *\r\n *\r\n * { domains : [\"DOMAIN1\", \"DOMAIN2\"],\r\n *   categorySet : {   cat1 : true, cat2 : true, ...}\r\n * }\r\n */\r\nexport function getDomainCategoryFilterForTargetCategories(model: IMatch.IModels, categories: string[], wordsonly: boolean): IMatch.IDomainCategoryFilter {\r\n    var res = {};\r\n    //\r\n    var fn = wordsonly ? getPotentialWordCategoriesForDomain : getCategoriesForDomain;\r\n    var domains = undefined as string[];\r\n    categories.forEach(function (category) {\r\n        var catdomains = getDomainsForCategory(model, category)\r\n        if (!domains) {\r\n            domains = catdomains;\r\n        } else {\r\n            domains = _.intersection(domains, catdomains);\r\n        }\r\n    });\r\n    if (domains.length === 0) {\r\n        throw new Error('categories ' + Utils.listToQuotedCommaAnd(categories) + ' have no common domain.')\r\n    }\r\n    domains.forEach(function (domain) {\r\n        fn(model, domain).forEach(function (wordcat) {\r\n            res[wordcat] = true;\r\n        });\r\n    });\r\n    Object.freeze(res);\r\n    return {\r\n        domains: domains,\r\n        categorySet: res\r\n    };\r\n}\r\n\r\n\r\nexport function getDomainCategoryFilterForTargetCategory(model: IMatch.IModels, category: string, wordsonly: boolean): IMatch.IDomainCategoryFilter {\r\n    return getDomainCategoryFilterForTargetCategories(model, [category], wordsonly);\r\n}\r\n\r\n\r\n"],"sourceRoot":"ABC"}