{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_model/src//projects/nodejs/botbuilder/mgnlq_model/src/../src/match/ifmatch.ts"],"names":[],"mappings":";;;AAGA,IAAkB,gBAIjB;AAJD,WAAkB,gBAAgB;IAChC,6DAAW,CAAA;IACX,uDAAI,CAAA;IACJ,yDAAK,CAAA;AACP,CAAC,EAJiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAIjC;AAGY,QAAA,YAAY,GAAG,UAAU,CAAC;AAC1B,QAAA,UAAU,GAAG,QAAQ,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC;AAGlB,QAAA,iBAAiB,GAAG,eAAe,CAAC;AACpC,QAAA,eAAe,GAAG,aAAa,CAAC;AAK5C,CAAC;AAQD,CAAC;AAaW,QAAA,cAAc,GAAG,CAAC,eAAe,EAAE,aAAa;IACnC,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO;IAC3C,WAAW,EAAC,WAAW,EAAE,SAAS;IACnC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI;IAC/B,UAAU,EAAE,qBAAqB;IACjC,UAAU,EAAE,cAAc;IAC1B,YAAY,EAAE,aAAa;IAC3B,aAAa,EAAE,YAAY;CAC5B,CAAC;AAWb,QAAA,0BAA0B,GAAG,CAAC,eAAe,EAAE,aAAa;IACjD,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO;IAC5C,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI;CAChC,CAAC;AAmDvB,CAAC;AAOW,QAAA,QAAQ,GAAG;IACtB,MAAM,EAAG,GAAG;IACZ,IAAI,EAAG,GAAG;IACV,IAAI,EAAE,GAAG;IACT,IAAI,EAAG,GAAG;IACV,QAAQ,EAAG,GAAG;IACd,MAAM,EAAG,GAAG;IACZ,QAAQ,EAAG,GAAG;IACd,UAAU,EAAG,GAAG;IAChB,GAAG,EAAG,GAAG,CAAC,EAAE;CACb,CAAC;AAEF,IAAuB,YAGtB;AAHD,WAAuB,YAAY;IACjC,+CAAI,CAAA;IACJ,mDAAM,CAAA;AACR,CAAC,EAHsB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAGlC;AAKI,CAAC;AA2EL,CAAC;AAIe,CAAC;AAmCjB,CAAC;AAoCD,CAAC;AAaD,CAAC;AA4BF,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC9B,2DAAQ,CAAA;IACR,mEAAY,CAAA;AACd,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B;AAwBD,IAAkB,iBAGjB;AAHD,WAAkB,iBAAiB;IACjC,sCAAiB,CAAA;IACjB,sCAAiB,CAAA;AACnB,CAAC,EAHiB,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAGlC;AAAA,CAAC;AAgCD,CAAC;AAQD,CAAC;AAmBD,CAAC;AAmBD,CAAC","file":"ifmatch.js","sourcesContent":["\r\nimport * as mongoose from 'mongoose';\r\n\r\nexport const enum EnumResponseCode {\r\n  NOMATCH = 0,\r\n  EXEC,\r\n  QUERY\r\n}\r\n\r\n\r\nexport const CAT_CATEGORY = \"category\";\r\nexport const CAT_FILLER = \"filler\";\r\nexport const CAT_TOOL = \"tool\";\r\n\r\n\r\nexport const ERR_NO_KNOWN_WORD = \"NO_KNOWN_WORD\";\r\nexport const ERR_EMPTY_INPUT = \"EMPTY_INPUT\";\r\n\r\nexport interface IERError {\r\n  err_code : string,\r\n  text : string\r\n};\r\n\r\nexport interface IERErrorNO_KNOWN_WORD extends IERError{\r\n  context : {\r\n    token : string,\r\n    index: number,\r\n    tokens : string[]\r\n  }\r\n};\r\n\r\n\r\n\r\nexport interface IPromptDescription {\r\n  description: string,\r\n  type: string,\r\n  pattern: RegExp,\r\n  message: string,\r\n  default: string,\r\n  required: boolean\r\n}\r\n\r\nexport const aOperatorNames = [\"starting with\", \"ending with\",\r\n                          \"containing\", \"excluding\", \"having\", \"being\"\r\n                          ,\"more than\",\"less than\" ,\"exactly\",\r\n                          \"<\", \"<=\", \"!=\", \"=\", \">\", \">=\",\r\n                          \"order by\", \"order descending by\",\r\n                          \"existing\", \"not existing\",\r\n                          \"left_paren\", \"right_paren\",\r\n                          \"logical_and\", \"logical_or\"\r\n                        ];\r\nexport type OperatorName = \"starting with\" | \"ending with\"\r\n                        | \"containing\" | \"being\" | \"excluding\" | \"having\"\r\n                        | \"more than\" | \"less than\" | \"exactly\"\r\n                        | \"<\" | \"<=\"| \"!=\"| \"=\"| \">\"| \">=\"\r\n                        |\"order by\"| \"order descending by\"\r\n                        | \"existing\"| \"not existing\"\r\n                        | \"left_paren\"| \"right_paren\"\r\n                        | \"logical_and\" | \"logical_or\"\r\n                        ;\r\n\r\nexport const aAnySuccessorOperatorNames = [\"starting with\", \"ending with\",\r\n                        \"containing\", \"excluding\", \"having\", \"being\",\r\n                        \"<\", \"<=\", \"!=\", \"=\", \">\", \">=\"\r\n                      ];\r\n\r\n\r\nexport interface IOperator {\r\n  operator : OperatorName,\r\n  code : string,\r\n  arity : number,\r\n  argcategory : [ string[] ],\r\n  operatorpos? : number\r\n}\r\n\r\nexport type IOperators = { [key:string] : IOperator };\r\n\r\n\r\nexport type IRecord = { [key : string] : string };\r\n\r\n\r\nexport interface IWhatIsAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  category : string,\r\n  result: string,\r\n  _ranking : number\r\n}\r\n\r\n\r\nexport interface IProcessedWhatIsAnswers extends IProcessed {\r\n  sentences? : ISentence[],\r\n  answers : IWhatIsAnswer[]\r\n}\r\n\r\n\r\n\r\nexport interface IProcessedWhatIsTupelAnswers extends IProcessed {\r\n  sentences? : ISentence[],\r\n  tupelanswers : Array<IWhatIsTupelAnswer>\r\n}\r\n\r\n\r\nexport interface IWhatIsTupelAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  categories : string[],\r\n  result: string[],\r\n  _ranking : number\r\n}\r\n\r\n\r\nexport interface IMatchedSetRecord {\r\n  setId : string,\r\n  record : IRecord\r\n};\r\nexport type IMatchedSetRecords = IMatchedSetRecord[];\r\n/**\r\n * Map category -> value\r\n */\r\nexport type IMatchSet = { [key : string] : string};\r\n\r\nexport const WORDTYPE = {\r\n  FILLER : \"I\", // in, and,\r\n  FACT : \"F\",  // a model fact\r\n  TOOL: \"T\", // a tool name\r\n  META : \"M\",  // words like category, domain\r\n  CATEGORY : \"C\", // a category, e.g. BSPName\r\n  DOMAIN : \"D\", // a domain, e.g. Fiori Bom\r\n  OPERATOR : \"O\", // containing ,starting with\r\n  NUMERICARG : 'N', // a number\r\n  ANY : \"A\" //\r\n};\r\n\r\nexport /*const*/  enum EnumRuleType {\r\n  WORD,\r\n  REGEXP\r\n}\r\n\r\nexport interface IToolSet {\r\n      set: string[],\r\n      response: string\r\n    };\r\n\r\nexport type IToolSets = {\r\n    [key: string]: IToolSet\r\n    };\r\n/**\r\n * @interface ITool\r\n *\r\n * var oTool = { 'name' : 'FLPD',\r\n *   'requires' : { 'systemId' : {}, 'client' :{}},\r\n *   'optional' : { 'catalog' : {}, 'group' :{}}\r\n * };\r\n*/\r\nexport interface ITool {\r\n  name: string,\r\n  requires: { [key: string]: Object },\r\n  optional?: { [key: string]: Object },\r\n  sets?: IToolSets\r\n}\r\n\r\nexport interface IToolMatchResult {\r\n  required: { [key: string]: IWord },\r\n  missing: { [key: string]: number },\r\n  optional?: { [key: string]: IWord },\r\n  spurious: { [key: string]: number },\r\n  toolmentioned: IWord[]\r\n}\r\n\r\nexport interface IPrompt {\r\n  text: string,\r\n  category: string\r\n}\r\n\r\nexport interface IToolMatch {\r\n  toolmatchresult: IToolMatchResult,\r\n  sentence: ISentence,\r\n  tool: ITool,\r\n  rank: number\r\n}\r\n\r\nexport interface IWord {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  _ranking?: number,\r\n  levenmatch?: number,\r\n  reinforce?: number,\r\n  bitindex? : number,\r\n  rule? : mRule\r\n}\r\n\r\nexport type ISentence = Array<IWord>;\r\n\r\nexport interface IRule {\r\n  type: EnumRuleType,\r\n  key: string,\r\n  word?: string,\r\n  regexp?: RegExp,\r\n  argsMap?: { [key: number]: string }  // a map of regexp match group -> context key\r\n  // e.g. /([a-z0-9]{3,3})CLNT([\\d{3,3}])/\r\n  //      { 1 : \"systemId\", 2 : \"client\" }\r\n  follows: context\r\n}\r\n\r\nexport interface IntentRule {\r\n  type: EnumRuleType,\r\n  regexp: RegExp,\r\n  argsMap: { [key: string]: number }  // a map of regexp match group -> context key\r\n  // e.g. /([a-z0-9]{3,3})CLNT([\\d{3,3}])/\r\n  //      { 1 : \"systemId\", 2 : \"client\" }\r\n  follows?: context\r\n}\r\n\r\nexport interface IRange {\r\n  low: number, high: number,\r\n};\r\n\r\nexport interface IWordRange extends IRange\r\n{\r\n  rule? : mRule };\r\n/**\r\n * A rule matching a single string\r\n */\r\nexport interface mRule {\r\n  type: EnumRuleType,\r\n  word?: string,\r\n  lowercaseword? : string,\r\n  regexp?: RegExp,\r\n  matchedString?: string,\r\n  matchIndex?: number,\r\n  category: string,\r\n  range? :  IWordRange,\r\n  /* categorization */\r\n  wordType: string, // one of WORDTYPE\r\n  bitindex : number, // bitindex indicating domain\r\n  bitSentenceAnd : number, // a bitindex flaglist which has to be nonzero on and\r\n\r\n  /**\r\n   * only use an exact match\r\n   */\r\n  exactOnly? : boolean,\r\n  _ranking?: number\r\n}\r\n\r\nexport interface IWordRules {\r\n  rules : Array<mRule>,\r\n  bitindex: number\r\n}\r\n\r\nexport interface SplitRules {\r\n  allRules: Array<mRule>,\r\n  nonWordRules : Array<mRule>,\r\n  wordMap: { [key : string] : IWordRules },\r\n  wordCache :  { [key: string]: Array<ICategorizedString> }\r\n};\r\n\r\nexport interface ICategorizedString {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  score?: number,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport interface ICategorizedStringRanged extends ICategorizedString{\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  /**\r\n   * Length of the entry (for skipping following words)\r\n   */\r\n  score?: number,\r\n  span? : number,\r\n  rule : mRule,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport interface IProcessed {\r\n  tokens : string[],\r\n  errors? : IERError[]\r\n}\r\n\r\nexport interface IProcessedSentences extends IProcessed {\r\n  tokens : string[],\r\n  errors? : any,\r\n  sentences : ISentence[]\r\n};\r\n\r\nexport type ICategoryFilter = { [key: string]: boolean };\r\n\r\n\r\nexport type IDomainCategoryFilter = {\r\n  domains : string[],\r\n  categorySet : { [key: string]: boolean }\r\n}\r\n\r\n\r\nexport interface IProcessedExtractedCategories extends IProcessed {\r\n  categories : string[],\r\n};\r\n\r\n\r\n\r\nexport type context = { [key: string]: string };\r\n\r\n/**\r\n * Defines the interface for an analysis\r\n * reponse\r\n */\r\nexport interface IResponse {\r\n  rating: number,\r\n  type: EnumResponseCode,\r\n  query: string,\r\n  context: { [key: string]: string },\r\n  text: string,\r\n  action: IAction,\r\n  prompts: {\r\n    [key: string]: {\r\n      text: string,\r\n      /**\r\n       * Follows the features of NPM prompts\r\n       */\r\n      description: IPromptDescription\r\n    };\r\n  }\r\n}\r\n\r\nexport const enum EnumActionType {\r\n  STARTURL,\r\n  STARTCMDLINE\r\n}\r\n\r\nexport interface IAction {\r\n  data: any,\r\n  type: EnumActionType,\r\n  pattern: string,\r\n  concrete: string\r\n}\r\n\r\n\r\n\r\n\r\nexport interface IRawSchema {\r\n    props: any[],\r\n    index : any\r\n}\r\n\r\nexport interface QBEColumnProp {\r\n      defaultWidth?: number,\r\n      QBE: boolean,\r\n      LUNRIndex?: boolean,\r\n      QBEInclude? : boolean\r\n}\r\n\r\nexport const enum IMongooseBaseType {\r\n  Number = \"Number\",\r\n  String = \"String\"\r\n};\r\n\r\nexport type IMongooseTypeDecl = IMongooseBaseType | IMongooseBaseType[];\r\n\r\n\r\nexport interface IModelCategoryRec {\r\n    category : string,\r\n    category_description : string,\r\n    QBEColumnProps : QBEColumnProp,\r\n    category_synonyms: string[],\r\n    wordindex : boolean,\r\n    exactmatch: boolean,\r\n    showURI : boolean,\r\n    showURIRank : boolean,\r\n    type : IMongooseTypeDecl\r\n}\r\n\r\nexport interface IModelDoc {\r\n    domain : string,\r\n    modelname? : string,\r\n    collectionname? : string,\r\n    domain_description : string\r\n    _categories : IModelCategoryRec[],\r\n    columns: string[],\r\n    domain_synonyms : string[]\r\n\r\n}\r\n\r\nexport interface CatMongoMap  { [key: string] : {\r\n        paths : string[], // individual segments, can be  [\"A\",\"[]\",\"B\"] , [\"A\", \"B\"]  or [\"A\", \"[]\"]\r\n        fullpath : string, // the mongoose path as written, e.g. A.B\r\n    }\r\n};\r\n\r\n\r\nexport interface IExtendedSchema extends IRawSchema{\r\n    domain : string,\r\n    modelname : string,\r\n    mongoosemodelname : string,\r\n    collectionname : string\r\n};\r\n\r\n\r\nexport interface ICategoryDesc {\r\n  category: string,\r\n  importance? : number,\r\n  category_description : string,\r\n  iskey? : boolean,\r\n  wordindex : boolean,\r\n  exactmatch: boolean,\r\n  category_synonyms? : string[];\r\n}\r\n\r\n\r\nexport interface IModelHandleRaw {\r\n    mongoose: mongoose.Mongoose,\r\n    modelDocs: { [key: string]: IModelDoc },\r\n    modelESchemas: { [key: string]: IExtendedSchema },\r\n    mongoMaps: { [key: string]: CatMongoMap },\r\n};\r\n\r\n\r\nexport interface IModel {\r\n    domain: string,\r\n    modelname? : string,\r\n    bitindex : number,\r\n    description? : string,\r\n //   tool: ITool,\r\n //   toolhidden?: boolean,\r\n    synonyms?: { [key: string]: string[] },\r\n    categoryDescribed :  { name : string,\r\n        description? : string,\r\n        key? : string }[],\r\n    category: string[],\r\n    columns? : string[]\r\n   // wordindex: string[],\r\n   //  exactmatch? : string[],\r\n    hidden: string[]\r\n};\r\n\r\nexport interface IModels {\r\n    mongoHandle : IModelHandleRaw\r\n    full : {\r\n      domain : { [key : string] : {\r\n          description: string,\r\n          bitindex : number,\r\n          categories : { [key : string] : ICategoryDesc }\r\n        }\r\n      }\r\n    },\r\n    rawModels : { [key : string] : IModel};\r\n    domains: string[],\r\n    category: string[],\r\n    operators : { [key: string] : IOperator },\r\n    mRules: mRule[],\r\n    rules : SplitRules,\r\n    records?: any[]\r\n    seenRules?: { [key: string]: mRule[] },\r\n    meta : {\r\n        // entity -> relation -> target\r\n        t3 : { [key: string] : { [key : string] : any }}\r\n    }\r\n}\r\n"],"sourceRoot":"ABC"}